{
  "id": "schema",
  "name": "Schema Violations",
  "description": "ALL data types MUST be defined as Schema. Use Schema.Class for entities with methods, Schema.TaggedClass for discriminated unions, tagged unions over optional properties. NEVER use Schema.Any/Schema.Unknown except for genuinely unconstrained values.",
  "patterns": [
    {
      "id": "interface-to-schema-class",
      "rule": "Plain TypeScript interfaces → Schema.Class",
      "example": {
        "description": "Domain entity definition",
        "bad": "interface User {\n  id: string\n  email: string\n  name: string\n  createdAt: Date\n}",
        "good": "class User extends Schema.Class<User>(\"User\")({\n  id: Schema.String.pipe(Schema.brand(\"UserId\")),\n  email: Schema.String.pipe(Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/)),\n  name: Schema.String.pipe(Schema.nonEmptyString()),\n  createdAt: Schema.Date,\n}) {\n  get emailDomain() {\n    return this.email.split(\"@\")[1]\n  }\n}"
      }
    },
    {
      "id": "type-alias-to-schema",
      "rule": "Plain TypeScript interfaces → Schema.Class",
      "example": {
        "description": "Simple type alias",
        "bad": "type Point = { x: number; y: number }",
        "good": "const Point = Schema.Struct({\n  x: Schema.Number,\n  y: Schema.Number,\n})\ntype Point = Schema.Schema.Type<typeof Point>"
      }
    },
    {
      "id": "union-type-to-schema-union",
      "rule": "Plain TypeScript interfaces → Schema.Class",
      "example": {
        "description": "Union type",
        "bad": "type Status = \"pending\" | \"active\" | \"completed\"\ntype Result = Success | Failure",
        "good": "const Status = Schema.Literal(\"pending\", \"active\", \"completed\")\ntype Status = Schema.Schema.Type<typeof Status>\n\n// For complex unions, use TaggedClass\nconst Result = Schema.Union(Success, Failure)\ntype Result = Schema.Schema.Type<typeof Result>"
      }
    },
    {
      "id": "struct-to-class-methods",
      "rule": "Schema.Struct for domain entities → Schema.Class (with methods)",
      "example": {
        "description": "Entity needing methods",
        "bad": "const User = Schema.Struct({\n  id: Schema.String,\n  firstName: Schema.String,\n  lastName: Schema.String,\n})\n\n// Helper function outside schema\nconst getFullName = (user: User) => `${user.firstName} ${user.lastName}`",
        "good": "class User extends Schema.Class<User>(\"User\")({\n  id: Schema.String,\n  firstName: Schema.String,\n  lastName: Schema.String,\n}) {\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`\n  }\n}"
      }
    },
    {
      "id": "struct-to-class-computed",
      "rule": "Schema.Struct for domain entities → Schema.Class (with methods)",
      "example": {
        "description": "Entity with computed properties",
        "bad": "const Order = Schema.Struct({\n  items: Schema.Array(OrderItem),\n  discount: Schema.Number,\n})\n\nconst getTotal = (order: Order) =>\n  order.items.reduce((sum, i) => sum + i.price, 0) * (1 - order.discount)",
        "good": "class Order extends Schema.Class<Order>(\"Order\")({\n  items: Schema.Array(OrderItem),\n  discount: Schema.Number,\n}) {\n  get subtotal() {\n    return Array.reduce(this.items, 0, (sum, i) => sum + i.price)\n  }\n  get total() {\n    return this.subtotal * (1 - this.discount)\n  }\n}"
      }
    },
    {
      "id": "optional-to-tagged-union-order",
      "rule": "Optional properties for state → Tagged unions",
      "example": {
        "description": "Order status with optional fields",
        "bad": "const Order = Schema.Struct({\n  orderId: Schema.String,\n  items: Schema.Array(Schema.String),\n  trackingNumber: Schema.optional(Schema.String),\n  shippedAt: Schema.optional(Schema.Date),\n  deliveredAt: Schema.optional(Schema.Date),\n})",
        "good": "class Pending extends Schema.TaggedClass<Pending>()(\"Pending\", {\n  orderId: Schema.String,\n  items: Schema.Array(Schema.String),\n}) {}\n\nclass Shipped extends Schema.TaggedClass<Shipped>()(\"Shipped\", {\n  orderId: Schema.String,\n  items: Schema.Array(Schema.String),\n  trackingNumber: Schema.String,\n  shippedAt: Schema.Date,\n}) {}\n\nclass Delivered extends Schema.TaggedClass<Delivered>()(\"Delivered\", {\n  orderId: Schema.String,\n  items: Schema.Array(Schema.String),\n  deliveredAt: Schema.Date,\n}) {}\n\nconst Order = Schema.Union(Pending, Shipped, Delivered)\ntype Order = Schema.Schema.Type<typeof Order>"
      }
    },
    {
      "id": "optional-to-tagged-union-auth",
      "rule": "Optional properties for state → Tagged unions",
      "example": {
        "description": "Authentication state",
        "bad": "const AuthState = Schema.Struct({\n  isAuthenticated: Schema.Boolean,\n  user: Schema.optional(UserSchema),\n  error: Schema.optional(Schema.String),\n})",
        "good": "class Anonymous extends Schema.TaggedClass<Anonymous>()(\"Anonymous\", {}) {}\n\nclass Authenticated extends Schema.TaggedClass<Authenticated>()(\"Authenticated\", {\n  user: UserSchema,\n  token: Schema.String,\n}) {}\n\nclass AuthError extends Schema.TaggedClass<AuthError>()(\"AuthError\", {\n  message: Schema.String,\n}) {}\n\nconst AuthState = Schema.Union(Anonymous, Authenticated, AuthError)"
      }
    },
    {
      "id": "any-unknown-type-weakening",
      "rule": "Schema.Any/Schema.Unknown → Proper typed schemas (unless genuinely unconstrained)",
      "example": {
        "description": "Type weakening with Unknown",
        "bad": "const ApiResponse = Schema.Struct({\n  status: Schema.Number,\n  data: Schema.Unknown, // What's in here?\n})\n\nconst Config = Schema.Struct({\n  settings: Schema.Any, // Lazy - define the shape!\n})",
        "good": "// Define specific response schemas\nconst UserResponse = Schema.Struct({\n  status: Schema.Literal(200),\n  data: User,\n})\n\nconst ErrorResponse = Schema.Struct({\n  status: Schema.Number.pipe(Schema.greaterThan(299)),\n  error: Schema.String,\n})\n\nconst ApiResponse = Schema.Union(UserResponse, ErrorResponse)"
      }
    },
    {
      "id": "unknown-legitimate-cause",
      "rule": "Schema.Any/Schema.Unknown → Proper typed schemas (unless genuinely unconstrained)",
      "example": {
        "description": "Legitimate use of Schema.Unknown (exception cause)",
        "bad": "// Overusing Schema.Unknown\nconst Event = Schema.Struct({\n  type: Schema.String,\n  payload: Schema.Unknown, // Should be typed\n})",
        "good": "// Schema.Unknown is OK for genuinely unconstrained data\nclass AppError extends Schema.TaggedError<AppError>()(\"AppError\", {\n  message: Schema.String,\n  cause: Schema.Unknown, // Legitimate: captures arbitrary caught exceptions\n}) {}\n\n// But domain data should be typed\nclass UserCreated extends Schema.TaggedClass<UserCreated>()(\"UserCreated\", {\n  userId: Schema.String,\n  email: Schema.String,\n}) {}"
      }
    },
    {
      "id": "json-parse-to-schema-parsejson",
      "rule": "JSON.parse() → Schema.parseJson()",
      "example": {
        "description": "Parsing JSON string",
        "bad": "const data = JSON.parse(jsonString)\n// data is 'any' - no validation",
        "good": "const parseUser = Schema.decodeUnknownSync(\n  Schema.parseJson(User)\n)\nconst user = parseUser(jsonString)\n// user is fully typed and validated"
      }
    },
    {
      "id": "json-parse-effect",
      "rule": "JSON.parse() → Schema.parseJson()",
      "example": {
        "description": "JSON parsing with Effect error handling",
        "bad": "try {\n  const data = JSON.parse(jsonString)\n  processUser(data)\n} catch (e) {\n  console.error(\"Invalid JSON\")\n}",
        "good": "const parseUser = Schema.decodeUnknown(Schema.parseJson(User))\n\npipe(\n  parseUser(jsonString),\n  Effect.map(processUser),\n  Effect.catchTag(\"ParseError\", (e) =>\n    Effect.logError(\"Invalid user JSON\", e)\n  )\n)"
      }
    },
    {
      "id": "json-parse-two-steps",
      "rule": "JSON.parse() → Schema.parseJson()",
      "example": {
        "description": "Separate JSON.parse then validate (WRONG)",
        "bad": "// Two separate failure points\nconst parsed = JSON.parse(jsonString)  // Can throw!\nconst validated = Schema.decodeUnknownSync(MySchema)(parsed)",
        "good": "// Schema.parseJson handles both in one type-safe step\nconst MyData = Schema.parseJson(Schema.Struct({\n  name: Schema.String,\n  count: Schema.Number\n}))\n\nconst data = Schema.decodeUnknownSync(MyData)(jsonString)"
      }
    },
    {
      "id": "missing-brand-ids",
      "rule": "Raw primitives for IDs → Schema.brand",
      "example": {
        "description": "Unbranded ID types",
        "bad": "const User = Schema.Struct({\n  id: Schema.String,\n  email: Schema.String,\n})\n\n// Nothing prevents mixing up userId and orderId\nconst getOrder = (orderId: string) => ...\ngetOrder(user.id)  // Oops! Used userId as orderId",
        "good": "const UserId = Schema.String.pipe(Schema.brand(\"UserId\"))\nconst OrderId = Schema.String.pipe(Schema.brand(\"OrderId\"))\n\nclass User extends Schema.Class<User>(\"User\")({\n  id: UserId,\n  email: Schema.String,\n}) {}\n\n// Type error: UserId is not assignable to OrderId\nconst getOrder = (orderId: Schema.Schema.Type<typeof OrderId>) => ...\ngetOrder(user.id)  // Type error!"
      }
    },
    {
      "id": "data-tagged-error-to-schema",
      "rule": "Data.TaggedError → Schema.TaggedError",
      "example": {
        "description": "Error type definition",
        "bad": "import { Data } from \"effect\"\n\nclass UserNotFound extends Data.TaggedError(\"UserNotFound\")<{\n  userId: string\n}> {}",
        "good": "// Schema.TaggedError works with Schema.is(), catchTag, and Match.tag\nclass UserNotFound extends Schema.TaggedError<UserNotFound>()(\"UserNotFound\", {\n  userId: Schema.String\n}) {}"
      }
    },
    {
      "id": "plain-error-class",
      "rule": "Plain Error class → Schema.TaggedError",
      "example": {
        "description": "Domain error types",
        "bad": "class UserNotFoundError extends Error {\n  constructor(public userId: string) {\n    super(`User ${userId} not found`)\n    this.name = \"UserNotFoundError\"\n  }\n}",
        "good": "class UserNotFound extends Schema.TaggedError<UserNotFound>()(\"UserNotFound\", {\n  userId: Schema.String,\n}) {}"
      }
    },
    {
      "id": "manual-conversion-to-transform",
      "rule": "Manual type conversions → Schema.transform",
      "example": {
        "description": "Bidirectional string-to-number conversion",
        "bad": "const parseNumber = (s: string): number => parseFloat(s)\nconst formatNumber = (n: number): string => String(n)\n\n// Manual conversion at every use site\nconst value = parseNumber(input)\nconst output = formatNumber(result)",
        "good": "const NumberFromString = Schema.transform(\n  Schema.String,\n  Schema.Number,\n  {\n    decode: (s) => parseFloat(s),\n    encode: (n) => String(n)\n  }\n)\n\n// Use schema for automatic conversion\nconst value = Schema.decodeSync(NumberFromString)(input)  // \"42\" → 42\nconst output = Schema.encodeSync(NumberFromString)(result) // 42 → \"42\""
      }
    },
    {
      "id": "date-string-to-schema-date",
      "rule": "Manual type conversions → Schema.transform",
      "example": {
        "description": "Date string to Date object",
        "bad": "const parseDate = (s: string) => new Date(s)\nconst formatDate = (d: Date) => d.toISOString()\n\nconst data = {\n  createdAt: parseDate(json.createdAt)\n}",
        "good": "// Use built-in DateFromString or define custom\nconst ApiResponse = Schema.Struct({\n  createdAt: Schema.DateFromString  // Automatic ISO string ↔ Date\n})\n\nconst data = Schema.decodeUnknownSync(ApiResponse)(json)"
      }
    },
    {
      "id": "cents-dollars-transform",
      "rule": "Manual type conversions → Schema.transform",
      "example": {
        "description": "Domain transformation (cents to dollars)",
        "bad": "interface Price {\n  cents: number\n}\n\nconst toDollars = (p: Price) => p.cents / 100\nconst toCents = (dollars: number) => Math.round(dollars * 100)",
        "good": "// Schema captures the transformation bidirectionally\nconst Dollars = Schema.transform(\n  Schema.Number.pipe(Schema.int()),  // Cents (external/encoded)\n  Schema.Number,                      // Dollars (internal/decoded)\n  {\n    decode: (cents) => cents / 100,\n    encode: (dollars) => Math.round(dollars * 100)\n  }\n)\n\n// API sends cents, code works with dollars\nconst price = Schema.decodeSync(Dollars)(4999)  // → 49.99"
      }
    },
    {
      "id": "enum-to-literal",
      "rule": "TypeScript enum → Schema.Literal",
      "example": {
        "description": "Converting TypeScript enums",
        "bad": "enum Status {\n  Pending = \"pending\",\n  Active = \"active\",\n  Completed = \"completed\"\n}",
        "good": "// Prefer Schema.Literal for union of string values\nconst Status = Schema.Literal(\"pending\", \"active\", \"completed\")\ntype Status = Schema.Schema.Type<typeof Status>\n\n// If you must use existing enum, wrap it\nenum LegacyStatus { Pending = \"pending\", Active = \"active\" }\nconst StatusFromEnum = Schema.Enums(LegacyStatus)"
      }
    },
    {
      "id": "schema-filters-validation",
      "rule": "Manual validation → Schema filters",
      "example": {
        "description": "Validation constraints in schema",
        "bad": "const validateEmail = (s: string) => {\n  if (!s.includes(\"@\")) throw new Error(\"Invalid email\")\n  return s\n}\n\nconst validateAge = (n: number) => {\n  if (n < 0 || n > 150) throw new Error(\"Invalid age\")\n  return n\n}",
        "good": "// Validation built into schema definition\nconst Email = Schema.String.pipe(\n  Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/),\n  Schema.annotations({ identifier: \"Email\" })\n)\n\nconst Age = Schema.Number.pipe(\n  Schema.int(),\n  Schema.between(0, 150),\n  Schema.annotations({ identifier: \"Age\" })\n)\n\nclass User extends Schema.Class<User>(\"User\")({\n  email: Email,\n  age: Age,\n}) {}"
      }
    }
  ]
}
