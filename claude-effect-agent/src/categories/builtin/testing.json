{
  "id": "testing",
  "name": "Testing Violations",
  "description": "ALL Effect tests MUST use @effect/vitest. NEVER use Effect.runPromise in tests. NEVER hand-craft test data - use Arbitrary.make(Schema). Combine service test layers with property testing for 100% coverage.",
  "rules": [
    {
      "rule": "Effect.runPromise in tests → it.effect from @effect/vitest",
      "example": {
        "description": "Test with service dependencies",
        "bad": "it(\"should process order\", async () => {\n  const result = await Effect.runPromise(\n    processOrder(order).pipe(\n      Effect.provide(TestLayer)\n    )\n  )\n  expect(result.status).toBe(\"completed\")\n})",
        "good": "it.effect(\"should process order\", () =>\n  Effect.gen(function* () {\n    const result = yield* processOrder(order)\n    expect(result.status).toBe(\"completed\")\n  }).pipe(Effect.provide(TestLayer))\n)"
      }
    },
    {
      "rule": "import { it } from \"vitest\" → import from @effect/vitest",
      "example": {
        "description": "Test file imports",
        "bad": "import { describe, it, expect } from \"vitest\"\nimport { Effect } from \"effect\"\n\ndescribe(\"UserService\", () => {\n  it(\"should create user\", async () => {\n    const result = await Effect.runPromise(createUser(data))\n    expect(result).toBeDefined()\n  })\n})",
        "good": "import { describe, it, expect } from \"@effect/vitest\"\nimport { Effect } from \"effect\"\n\ndescribe(\"UserService\", () => {\n  it.effect(\"should create user\", () =>\n    Effect.gen(function* () {\n      const result = yield* createUser(data)\n      expect(result).toBeDefined()\n    })\n  )\n})"
      }
    },
    {
      "rule": "Hard-coded test data → Arbitrary.make(Schema)",
      "example": {
        "description": "Multiple test inputs",
        "bad": "const testOrders = [\n  { id: \"order-1\", total: 100, items: [\"a\", \"b\"] },\n  { id: \"order-2\", total: 200, items: [\"c\"] },\n  { id: \"order-3\", total: 50, items: [] },\n]\n\ntestOrders.forEach((order) => {\n  it(`should process order ${order.id}`, async () => {\n    const result = await processOrder(order)\n    expect(result).toBeDefined()\n  })\n})",
        "good": "it.effect.prop(\n  \"should process all valid orders\",\n  [Arbitrary.make(Order)],\n  ([order]) =>\n    Effect.gen(function* () {\n      const result = yield* processOrder(order)\n      expect(result).toBeDefined()\n    })\n)"
      }
    },
    {
      "rule": "fast-check .filter() → Schema constraints",
      "example": {
        "description": "Complex Schema constraints",
        "bad": "const validUser = fc.record({\n  id: fc.string(),\n  name: fc.string(),\n  age: fc.integer(),\n  email: fc.string(),\n}).filter((u) =>\n  u.name.length > 0 &&\n  u.age >= 18 &&\n  u.email.includes(\"@\")\n)",
        "good": "class User extends Schema.Class<User>(\"User\")({\n  id: Schema.String.pipe(Schema.minLength(1)),\n  name: Schema.String.pipe(Schema.nonEmptyString()),\n  age: Schema.Number.pipe(Schema.int(), Schema.greaterThanOrEqualTo(18)),\n  email: Schema.String.pipe(Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/)),\n}) {}\n\n// Arbitrary generates only valid users - no filtering needed\nconst UserArbitrary = Arbitrary.make(User)"
      }
    },
    {
      "rule": "Manual property tests → it.prop with Arbitrary",
      "example": {
        "description": "Property test with Effect",
        "bad": "it(\"should process orders correctly\", async () => {\n  const orders = generateTestOrders(100)\n\n  for (const order of orders) {\n    const result = await Effect.runPromise(processOrder(order))\n    expect(result.status).toBe(\"completed\")\n  }\n})",
        "good": "it.effect.prop(\n  \"should process any valid order\",\n  [Arbitrary.make(Order)],\n  ([order]) =>\n    Effect.gen(function* () {\n      const result = yield* processOrder(order)\n      expect(result.status).toBe(\"completed\")\n    })\n)"
      }
    },
    {
      "rule": "Manual fc.assert/fc.property → it.prop",
      "example": {
        "description": "Converting fc.assert pattern",
        "bad": "import * as fc from \"fast-check\"\n\nit(\"should be commutative\", () => {\n  fc.assert(\n    fc.property(fc.integer(), fc.integer(), (a, b) => {\n      expect(a + b).toBe(b + a)\n    })\n  )\n})",
        "good": "import { it, expect } from \"@effect/vitest\"\nimport { Schema } from \"effect\"\n\nit.prop(\"should be commutative\", [Schema.Int, Schema.Int], ([a, b]) => {\n  expect(a + b).toBe(b + a)\n})"
      }
    },
    {
      "rule": "Direct service usage in tests → it.layer with test Layer",
      "example": {
        "description": "Testing with service dependencies",
        "bad": "// Tests hit real database!\nit.effect(\"should get user\", () =>\n  Effect.gen(function* () {\n    const repo = yield* UserRepository\n    const user = yield* repo.findById(\"123\")\n    expect(user).toBeDefined()\n  }).pipe(Effect.provide(UserRepositoryLive))\n)",
        "good": "import { it, expect, layer } from \"@effect/vitest\"\n\n// Test layer with in-memory store\nconst UserRepositoryTest = Layer.effect(\n  UserRepository,\n  Effect.gen(function* () {\n    const store = yield* Ref.make<Map<string, User>>(new Map())\n    return {\n      findById: (id) => Effect.gen(function* () {\n        const users = yield* Ref.get(store)\n        return yield* Option.match(Option.fromNullable(users.get(id)), {\n          onNone: () => Effect.fail(new UserNotFound({ userId: id })),\n          onSome: Effect.succeed\n        }).pipe(Effect.flatten)\n      }),\n      save: (user) => Ref.update(store, (m) => new Map(m).set(user.id, user))\n    }\n  })\n)\n\nlayer(UserRepositoryTest)(\"UserService\", (it) => {\n  it.effect.prop(\n    \"should save and find any user\",\n    [Arbitrary.make(User)],\n    ([user]) =>\n      Effect.gen(function* () {\n        const repo = yield* UserRepository\n        yield* repo.save(user)\n        const found = yield* repo.findById(user.id)\n        expect(found).toEqual(user)\n      })\n  )\n})"
      }
    },
    {
      "rule": "Hard-coded values in test layers → Arbitrary-generated values",
      "example": {
        "description": "Test layer with hard-coded responses",
        "bad": "const UserApiTest = Layer.succeed(UserApi, {\n  // Hard-coded response - same value every test run\n  getUser: (id) => Effect.succeed({\n    id: \"test-123\",\n    name: \"Test User\",\n    email: \"test@test.com\"\n  }),\n  // Not implemented - this code path won't be tested\n  updateUser: () => Effect.fail(new Error(\"Not implemented\"))\n})",
        "good": "const UserApiTest = Layer.effect(\n  UserApi,\n  Effect.sync(() => {\n    // Generate different values for each test run\n    const UserArb = Arbitrary.make(User)(fc)\n    return {\n      getUser: (id) => Effect.succeed(\n        fc.sample(UserArb, 1)[0]\n      ),\n      updateUser: (user) => Effect.void\n    }\n  })\n)"
      }
    },
    {
      "rule": "Combine service test layers + Arbitrary for 100% coverage",
      "example": {
        "description": "Full property-based integration test",
        "bad": "// Partial coverage: hard-coded data + real services\nit(\"should process order\", async () => {\n  const testOrder = { id: \"order-1\", total: 100, userId: \"user-1\" }\n  const result = await Effect.runPromise(\n    processOrder(testOrder).pipe(Effect.provide(RealServicesLayer))\n  )\n  expect(result.status).toBe(\"completed\")\n})",
        "good": "// 100% coverage: test layers + generated data\nconst TestEnv = Layer.merge(\n  UserApiTest,\n  Layer.merge(OrderRepositoryTest, PaymentGatewayTest)\n)\n\nlayer(TestEnv)(\"Order Processing\", (it) => {\n  it.effect.prop(\n    \"should process any valid order\",\n    [Arbitrary.make(Order)],\n    ([order]) =>\n      Effect.gen(function* () {\n        const result = yield* processOrder(order)\n        expect(result.status).toBe(\"completed\")\n      })\n  )\n})"
      }
    },
    {
      "rule": "Manual TestClock.layer → automatic in it.effect",
      "example": {
        "description": "Time-based testing",
        "bad": "it(\"should timeout after delay\", async () => {\n  await Effect.runPromise(\n    Effect.gen(function* () {\n      const fiber = yield* Effect.fork(Effect.sleep(\"1 hour\"))\n      yield* TestClock.adjust(\"1 hour\")\n      yield* Fiber.join(fiber)\n    }).pipe(Effect.provide(TestClock.layer))\n  )\n})",
        "good": "// it.effect automatically provides TestClock\nit.effect(\"should timeout after delay\", () =>\n  Effect.gen(function* () {\n    const fiber = yield* Effect.fork(Effect.sleep(\"1 hour\"))\n    yield* TestClock.adjust(\"1 hour\")\n    yield* Fiber.join(fiber)\n  })\n)"
      }
    },
    {
      "rule": "Call addEqualityTesters() for Effect type equality",
      "example": {
        "description": "Setup for Effect equality assertions",
        "bad": "// Effect types may not compare correctly in expect()\nimport { it, expect } from \"@effect/vitest\"\n\nit.effect(\"should match\", () =>\n  Effect.gen(function* () {\n    const result = yield* getOption()\n    expect(result).toEqual(Option.some(42))  // May fail incorrectly\n  })\n)",
        "good": "// In vitest.setup.ts or at top of test file\nimport { addEqualityTesters } from \"@effect/vitest\"\naddEqualityTesters()\n\n// Now Effect types compare correctly\nit.effect(\"should match\", () =>\n  Effect.gen(function* () {\n    const result = yield* getOption()\n    expect(result).toEqual(Option.some(42))  // Works correctly\n  })\n)"
      }
    },
    {
      "rule": "Tests with resources → it.scoped",
      "example": {
        "description": "Testing with acquireRelease resources",
        "bad": "it(\"should use database connection\", async () => {\n  const conn = await connect()\n  try {\n    const result = await conn.query(\"SELECT 1\")\n    expect(result).toBeDefined()\n  } finally {\n    await conn.close()  // Manual cleanup\n  }\n})",
        "good": "// it.scoped automatically handles resource cleanup\nit.scoped(\"should use database connection\", () =>\n  Effect.gen(function* () {\n    const conn = yield* acquireDbConnection  // acquireRelease resource\n    const result = yield* conn.query(\"SELECT 1\")\n    expect(result).toBeDefined()\n    // Connection automatically released when test ends\n  })\n)"
      }
    },
    {
      "rule": "Tests needing real environment → it.live",
      "example": {
        "description": "Testing with real clock/environment",
        "bad": "it.effect(\"should measure real time\", () =>\n  Effect.gen(function* () {\n    const start = Date.now()\n    yield* Effect.sleep(\"10 millis\")  // Uses TestClock - no real delay!\n    const elapsed = Date.now() - start\n    expect(elapsed).toBeGreaterThanOrEqual(10)  // Fails!\n  })\n)",
        "good": "// it.live uses real clock, logger, etc.\nit.live(\"should measure real time\", () =>\n  Effect.gen(function* () {\n    const start = Date.now()\n    yield* Effect.sleep(\"10 millis\")  // Real 10ms delay\n    const elapsed = Date.now() - start\n    expect(elapsed).toBeGreaterThanOrEqual(10)  // Passes\n  })\n)"
      }
    },
    {
      "rule": "Inspecting error details → Effect.exit in it.effect",
      "example": {
        "description": "Asserting on error type and data",
        "bad": "it(\"should fail with UserNotFound\", async () => {\n  try {\n    await Effect.runPromise(getUser(\"nonexistent\"))\n    fail(\"Expected error\")\n  } catch (e) {\n    expect(e._tag).toBe(\"UserNotFound\")\n  }\n})",
        "good": "it.effect(\"should fail with UserNotFound\", () =>\n  Effect.gen(function* () {\n    const exit = yield* Effect.exit(getUser(\"nonexistent\"))\n\n    expect(Exit.isFailure(exit)).toBe(true)\n\n    Exit.match(exit, {\n      onFailure: (cause) => {\n        const error = Option.getOrThrow(Cause.failureOption(cause))\n        expect(Schema.is(UserNotFound)(error)).toBe(true)\n        expect(error.userId).toBe(\"nonexistent\")\n      },\n      onSuccess: () => { throw new Error(\"Expected failure\") }\n    })\n  })\n)"
      }
    },
    {
      "rule": "\"Not implemented\" in test layers → Arbitrary-generated responses",
      "example": {
        "description": "Anti-pattern: stubbing methods as not implemented",
        "bad": "const TestLayer = Layer.succeed(MyService, {\n  getUser: (id) => Effect.succeed({ id, name: \"Hardcoded\" }),\n  updateUser: () => Effect.fail(new Error(\"Not implemented\")),  // Won't test this path!\n  deleteUser: () => Effect.fail(new Error(\"Not implemented\")),\n})",
        "good": "// Generate valid responses so all code paths can be exercised\nconst TestLayer = Layer.effect(\n  MyService,\n  Effect.sync(() => {\n    const UserArb = Arbitrary.make(User)(fc)\n    return {\n      getUser: (id) => Effect.succeed(\n        fc.sample(UserArb, 1)[0]\n      ),\n      updateUser: (user) => Effect.void,\n      deleteUser: (id) => Effect.void,\n    }\n  })\n)"
      }
    }
  ]
}
