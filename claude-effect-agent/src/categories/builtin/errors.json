{
  "id": "errors",
  "name": "Error Handling",
  "description": "NEVER use throw, try/catch, or untyped Error classes. ALL errors MUST be typed using Schema.TaggedError. Use Effect.try/Effect.tryPromise to wrap code that may throw.",
  "rules": [
    {
      "rule": "Never use throw statements; use Effect.fail()",
      "example": {
        "description": "Conditional throw based on state",
        "bad": "function processOrder(order: Order) {\n  if (order.status === \"cancelled\") {\n    throw new Error(\"Cannot process cancelled order\")\n  }\n  if (order.total <= 0) {\n    throw new Error(\"Order total must be positive\")\n  }\n  return processValidOrder(order)\n}",
        "good": "class OrderCancelled extends Schema.TaggedError<OrderCancelled>()(\"OrderCancelled\", {\n  orderId: Schema.String\n}) {}\n\nclass InvalidTotal extends Schema.TaggedError<InvalidTotal>()(\"InvalidTotal\", {\n  total: Schema.Number\n}) {}\n\nconst processOrder = (order: Order) =>\n  Match.value(order).pipe(\n    Match.when({ status: \"cancelled\" }, (o) =>\n      Effect.fail(new OrderCancelled({ orderId: o.id }))\n    ),\n    Match.when({ total: (t) => t <= 0 }, (o) =>\n      Effect.fail(new InvalidTotal({ total: o.total }))\n    ),\n    Match.orElse((o) => processValidOrder(o))\n  )"
      }
    },
    {
      "rule": "Never use try/catch blocks; use Effect.try()",
      "example": {
        "description": "Multiple try/catch blocks",
        "bad": "async function processOrder(data: string) {\n  let order\n  try {\n    order = JSON.parse(data)\n  } catch (e) {\n    throw new Error(\"Invalid order JSON\")\n  }\n\n  try {\n    await saveOrder(order)\n  } catch (e) {\n    throw new Error(\"Failed to save order\")\n  }\n}",
        "good": "class InvalidOrderJson extends Schema.TaggedError<InvalidOrderJson>()(\"InvalidOrderJson\", {\n  data: Schema.String\n}) {}\n\nclass SaveOrderError extends Schema.TaggedError<SaveOrderError>()(\"SaveOrderError\", {\n  orderId: Schema.String,\n  cause: Schema.Unknown\n}) {}\n\nconst processOrder = (data: string) =>\n  Effect.gen(function* () {\n    const order = yield* Effect.try({\n      try: () => JSON.parse(data) as Order,\n      catch: () => new InvalidOrderJson({ data })\n    })\n\n    yield* Effect.tryPromise({\n      try: () => saveOrder(order),\n      catch: (e) => new SaveOrderError({ orderId: order.id, cause: e })\n    })\n  })"
      }
    },
    {
      "rule": "Never use try/catch with async; use Effect.tryPromise()",
      "example": {
        "description": "Wrapping async operation",
        "bad": "async function fetchUser(id: string): Promise<User> {\n  try {\n    const response = await fetch(`/users/${id}`)\n    return await response.json()\n  } catch (e) {\n    throw new Error(\"Failed to fetch user\")\n  }\n}",
        "good": "class FetchUserError extends Schema.TaggedError<FetchUserError>()(\"FetchUserError\", {\n  userId: Schema.String,\n  cause: Schema.Unknown\n}) {}\n\nconst fetchUser = (id: string) =>\n  Effect.tryPromise({\n    try: async () => {\n      const response = await fetch(`/users/${id}`)\n      return response.json() as Promise<User>\n    },\n    catch: (e) => new FetchUserError({ userId: id, cause: e })\n  })"
      }
    },
    {
      "rule": "Never use untyped errors; use Schema.TaggedError",
      "example": {
        "description": "Multiple error types",
        "bad": "class ValidationError extends Error {\n  constructor(public field: string, public message: string) {\n    super(message)\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(public resource: string, public id: string) {\n    super(`${resource} ${id} not found`)\n  }\n}",
        "good": "class ValidationError extends Schema.TaggedError<ValidationError>()(\"ValidationError\", {\n  field: Schema.String,\n  message: Schema.String,\n}) {}\n\nclass NotFoundError extends Schema.TaggedError<NotFoundError>()(\"NotFoundError\", {\n  resource: Schema.String,\n  id: Schema.String,\n}) {}\n\n// Now you can use catchTag for specific handling\nconst program = getUser(id).pipe(\n  Effect.catchTag(\"NotFoundError\", (e) =>\n    Effect.succeed(defaultUser)\n  ),\n  Effect.catchTag(\"ValidationError\", (e) =>\n    Effect.fail(new BadRequest({ message: e.message }))\n  )\n)"
      }
    },
    {
      "rule": "Never check error._tag manually; use Effect.catchTag",
      "example": {
        "description": "Recovering from specific errors",
        "bad": "const result = getUser(id).pipe(\n  Effect.catchAll((error) => {\n    if (error._tag === \"UserNotFound\") {\n      return Effect.succeed(defaultUser)\n    }\n    return Effect.fail(error)\n  })\n)",
        "good": "const result = getUser(id).pipe(\n  Effect.catchTag(\"UserNotFound\", () => Effect.succeed(defaultUser))\n)"
      }
    },
    {
      "rule": "Never use switch on error._tag; use Effect.catchTags",
      "example": {
        "description": "Handling multiple error types",
        "bad": "const result = processOrder(order).pipe(\n  Effect.catchAll((error) => {\n    switch (error._tag) {\n      case \"ValidationError\":\n        return Effect.fail(new BadRequest({ message: error.message }))\n      case \"NotFoundError\":\n        return Effect.succeed(defaultOrder)\n      default:\n        return Effect.fail(error)\n    }\n  })\n)",
        "good": "const result = processOrder(order).pipe(\n  Effect.catchTags({\n    ValidationError: (e) => Effect.fail(new BadRequest({ message: e.message })),\n    NotFoundError: () => Effect.succeed(defaultOrder)\n  })\n)"
      }
    },
    {
      "rule": "Never use catchAll for fallbacks; use Effect.orElse",
      "example": {
        "description": "Fallback to alternative",
        "bad": "const result = fetchFromPrimary().pipe(\n  Effect.catchAll(() => fetchFromBackup())\n)",
        "good": "const result = fetchFromPrimary().pipe(\n  Effect.orElse(() => fetchFromBackup())\n)"
      }
    },
    {
      "rule": "Never use setTimeout for timeouts; use Effect.timeout",
      "example": {
        "description": "Timeout with typed error",
        "bad": "const withTimeout = async <T>(promise: Promise<T>, ms: number): Promise<T> => {\n  const timeout = new Promise<never>((_, reject) =>\n    setTimeout(() => reject(new Error(\"Timeout\")), ms)\n  )\n  return Promise.race([promise, timeout])\n}",
        "good": "class TimeoutError extends Schema.TaggedError<TimeoutError>()(\"TimeoutError\", {\n  operation: Schema.String,\n}) {}\n\nconst result = yield* fetchData().pipe(\n  Effect.timeoutFail({\n    duration: \"5 seconds\",\n    onTimeout: () => new TimeoutError({ operation: \"fetchData\" })\n  })\n)"
      }
    },
    {
      "rule": "Never use manual retry loops; use Effect.retry with Schedule",
      "example": {
        "description": "Retry only for specific errors",
        "bad": "let attempts = 0\nwhile (attempts < 3) {\n  try {\n    return await fetchData()\n  } catch (e) {\n    if (e.code !== \"NETWORK_ERROR\") throw e\n    attempts++\n  }\n}",
        "good": "const result = yield* fetchData().pipe(\n  Effect.retry({\n    schedule: Schedule.recurs(3),\n    while: (error) =>\n      Match.value(error).pipe(\n        Match.tag(\"NetworkError\", () => true),\n        Match.orElse(() => false)\n      )\n  })\n)"
      }
    },
    {
      "rule": "Never use fail-fast Promise.all; use Effect.all with mode: \"either\"",
      "example": {
        "description": "Get Either results for each operation",
        "bad": "const results = await Promise.all(\n  items.map(processItem)\n)  // Fails on first error",
        "good": "// Each result is Either<E, A>\nconst results = yield* Effect.all(\n  Array.map(items, processItem),\n  { mode: \"either\" }\n)"
      }
    },
    {
      "rule": "Never use try/catch for Effect errors; use Effect.sandbox with Cause",
      "example": {
        "description": "Handling defects and expected errors",
        "bad": "try {\n  await Effect.runPromise(program)\n} catch (e) {\n  // Can't distinguish between expected errors and defects\n  console.error(e)\n}",
        "good": "const handled = Effect.sandbox(program).pipe(\n  Effect.catchAll((cause) =>\n    Match.value(cause).pipe(\n      Match.when(Cause.isFailure, () => {\n        // Expected error - recover gracefully\n        return Effect.succeed(fallback)\n      }),\n      Match.when(Cause.isDie, (c) => {\n        // Defect (bug) - log and recover\n        return Effect.logError(\"Unexpected defect\", c).pipe(\n          Effect.as(fallback)\n        )\n      }),\n      Match.when(Cause.isInterrupt, () => {\n        // Interruption - clean shutdown\n        return Effect.succeed(fallback)\n      }),\n      Match.orElse(() => Effect.succeed(fallback))\n    )\n  )\n)"
      }
    },
    {
      "rule": "Never rethrow transformed errors; use Effect.mapError",
      "example": {
        "description": "Transform low-level to domain errors",
        "bad": "const result = await fetch(url).catch((e) => {\n  throw new Error(`API failed: ${e.message}`)\n})",
        "good": "const result = yield* Effect.tryPromise({\n  try: () => fetch(url),\n  catch: (e) => new RawNetworkError({ cause: e })\n}).pipe(\n  Effect.mapError((e) => new ApiError({ url, cause: e }))\n)"
      }
    }
  ]
}
