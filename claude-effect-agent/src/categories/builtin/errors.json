{
  "id": "errors",
  "name": "Error Handling",
  "description": "NEVER use throw, try/catch, or untyped Error classes. ALL errors MUST be typed using Schema.TaggedError. Use Effect.try/Effect.tryPromise to wrap code that may throw.",
  "patterns": [
    {
      "id": "throw-to-effect-fail",
      "rule": "throw statements → Effect.fail()",
      "example": {
        "description": "Throwing domain error",
        "bad": "function getUser(id: string): User {\n  const user = db.find(id)\n  if (!user) {\n    throw new Error(\"User not found\")\n  }\n  return user\n}",
        "good": "const getUser = (id: string): Effect.Effect<User, UserNotFound> =>\n  Effect.gen(function* () {\n    const user = yield* findInDb(id)\n    return yield* pipe(\n      Option.fromNullable(user),\n      Option.match({\n        onNone: () => Effect.fail(new UserNotFound({ userId: id })),\n        onSome: Effect.succeed\n      })\n    )\n  })"
      }
    },
    {
      "id": "throw-validation",
      "rule": "throw statements → Effect.fail()",
      "example": {
        "description": "Validation error",
        "bad": "function validateEmail(email: string): string {\n  if (!email.includes(\"@\")) {\n    throw new Error(\"Invalid email\")\n  }\n  return email\n}",
        "good": "class InvalidEmail extends Schema.TaggedError<InvalidEmail>()(\"InvalidEmail\", {\n  email: Schema.String,\n}) {}\n\nconst validateEmail = (email: string): Effect.Effect<string, InvalidEmail> =>\n  email.includes(\"@\")\n    ? Effect.succeed(email)\n    : Effect.fail(new InvalidEmail({ email }))"
      }
    },
    {
      "id": "throw-conditional-to-match",
      "rule": "throw statements → Effect.fail()",
      "example": {
        "description": "Conditional throw based on state",
        "bad": "function processOrder(order: Order) {\n  if (order.status === \"cancelled\") {\n    throw new Error(\"Cannot process cancelled order\")\n  }\n  if (order.total <= 0) {\n    throw new Error(\"Order total must be positive\")\n  }\n  return processValidOrder(order)\n}",
        "good": "class OrderCancelled extends Schema.TaggedError<OrderCancelled>()(\"OrderCancelled\", {\n  orderId: Schema.String\n}) {}\n\nclass InvalidTotal extends Schema.TaggedError<InvalidTotal>()(\"InvalidTotal\", {\n  total: Schema.Number\n}) {}\n\nconst processOrder = (order: Order) =>\n  Match.value(order).pipe(\n    Match.when({ status: \"cancelled\" }, (o) =>\n      Effect.fail(new OrderCancelled({ orderId: o.id }))\n    ),\n    Match.when({ total: (t) => t <= 0 }, (o) =>\n      Effect.fail(new InvalidTotal({ total: o.total }))\n    ),\n    Match.orElse((o) => processValidOrder(o))\n  )"
      }
    },
    {
      "id": "try-catch-sync",
      "rule": "try/catch blocks → Effect.try()",
      "example": {
        "description": "Wrapping sync operation",
        "bad": "function parseConfig(json: string): Config {\n  try {\n    return JSON.parse(json)\n  } catch (e) {\n    throw new Error(\"Invalid config\")\n  }\n}",
        "good": "class ConfigParseError extends Schema.TaggedError<ConfigParseError>()(\"ConfigParseError\", {\n  cause: Schema.Unknown\n}) {}\n\nconst parseConfig = (json: string) =>\n  Effect.try({\n    try: () => JSON.parse(json) as Config,\n    catch: (e) => new ConfigParseError({ cause: e })\n  })"
      }
    },
    {
      "id": "try-catch-async",
      "rule": "try/catch blocks → Effect.tryPromise()",
      "example": {
        "description": "Wrapping async operation",
        "bad": "async function fetchUser(id: string): Promise<User> {\n  try {\n    const response = await fetch(`/users/${id}`)\n    return await response.json()\n  } catch (e) {\n    throw new Error(\"Failed to fetch user\")\n  }\n}",
        "good": "class FetchUserError extends Schema.TaggedError<FetchUserError>()(\"FetchUserError\", {\n  userId: Schema.String,\n  cause: Schema.Unknown\n}) {}\n\nconst fetchUser = (id: string) =>\n  Effect.tryPromise({\n    try: async () => {\n      const response = await fetch(`/users/${id}`)\n      return response.json() as Promise<User>\n    },\n    catch: (e) => new FetchUserError({ userId: id, cause: e })\n  })"
      }
    },
    {
      "id": "multiple-try-catch",
      "rule": "try/catch blocks → Effect.try()",
      "example": {
        "description": "Multiple try/catch blocks",
        "bad": "async function processOrder(data: string) {\n  let order\n  try {\n    order = JSON.parse(data)\n  } catch (e) {\n    throw new Error(\"Invalid order JSON\")\n  }\n\n  try {\n    await saveOrder(order)\n  } catch (e) {\n    throw new Error(\"Failed to save order\")\n  }\n}",
        "good": "class InvalidOrderJson extends Schema.TaggedError<InvalidOrderJson>()(\"InvalidOrderJson\", {\n  data: Schema.String\n}) {}\n\nclass SaveOrderError extends Schema.TaggedError<SaveOrderError>()(\"SaveOrderError\", {\n  orderId: Schema.String,\n  cause: Schema.Unknown\n}) {}\n\nconst processOrder = (data: string) =>\n  Effect.gen(function* () {\n    const order = yield* Effect.try({\n      try: () => JSON.parse(data) as Order,\n      catch: () => new InvalidOrderJson({ data })\n    })\n\n    yield* Effect.tryPromise({\n      try: () => saveOrder(order),\n      catch: (e) => new SaveOrderError({ orderId: order.id, cause: e })\n    })\n  })"
      }
    },
    {
      "id": "error-class-to-tagged",
      "rule": "Untyped errors → Schema.TaggedError",
      "example": {
        "description": "Plain Error class",
        "bad": "class UserNotFoundError extends Error {\n  constructor(public userId: string) {\n    super(`User ${userId} not found`)\n    this.name = \"UserNotFoundError\"\n  }\n}",
        "good": "class UserNotFound extends Schema.TaggedError<UserNotFound>()(\"UserNotFound\", {\n  userId: Schema.String,\n}) {}"
      }
    },
    {
      "id": "multiple-error-types",
      "rule": "Untyped errors → Schema.TaggedError",
      "example": {
        "description": "Multiple error types",
        "bad": "class ValidationError extends Error {\n  constructor(public field: string, public message: string) {\n    super(message)\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(public resource: string, public id: string) {\n    super(`${resource} ${id} not found`)\n  }\n}",
        "good": "class ValidationError extends Schema.TaggedError<ValidationError>()(\"ValidationError\", {\n  field: Schema.String,\n  message: Schema.String,\n}) {}\n\nclass NotFoundError extends Schema.TaggedError<NotFoundError>()(\"NotFoundError\", {\n  resource: Schema.String,\n  id: Schema.String,\n}) {}\n\n// Now you can use catchTag for specific handling\nconst program = getUser(id).pipe(\n  Effect.catchTag(\"NotFoundError\", (e) =>\n    Effect.succeed(defaultUser)\n  ),\n  Effect.catchTag(\"ValidationError\", (e) =>\n    Effect.fail(new BadRequest({ message: e.message }))\n  )\n)"
      }
    },
    {
      "id": "error-complex-payload",
      "rule": "Untyped errors → Schema.TaggedError",
      "example": {
        "description": "Error with complex payload",
        "bad": "class ApiError extends Error {\n  constructor(\n    public statusCode: number,\n    public body: unknown,\n    public headers: Record<string, string>\n  ) {\n    super(`API error: ${statusCode}`)\n  }\n}",
        "good": "class ApiError extends Schema.TaggedError<ApiError>()(\"ApiError\", {\n  statusCode: Schema.Number,\n  body: Schema.Unknown,\n  headers: Schema.Record({ key: Schema.String, value: Schema.String }),\n}) {\n  get isClientError() {\n    return this.statusCode >= 400 && this.statusCode < 500\n  }\n  get isServerError() {\n    return this.statusCode >= 500\n  }\n}"
      }
    },
    {
      "id": "effect-unknown-error",
      "rule": "Untyped errors → Schema.TaggedError",
      "example": {
        "description": "Effect with unknown error type",
        "bad": "const getUser = (id: string): Effect.Effect<User, unknown> =>\n  Effect.tryPromise(() => fetchUser(id))",
        "good": "class FetchError extends Schema.TaggedError<FetchError>()(\"FetchError\", {\n  cause: Schema.Unknown\n}) {}\n\nconst getUser = (id: string): Effect.Effect<User, FetchError> =>\n  Effect.tryPromise({\n    try: () => fetchUser(id),\n    catch: (e) => new FetchError({ cause: e })\n  })"
      }
    },
    {
      "id": "catch-tag-pattern",
      "rule": "Error handling with catchTag",
      "example": {
        "description": "Recovering from specific errors",
        "bad": "const result = getUser(id).pipe(\n  Effect.catchAll((error) => {\n    if (error._tag === \"UserNotFound\") {\n      return Effect.succeed(defaultUser)\n    }\n    return Effect.fail(error)\n  })\n)",
        "good": "const result = getUser(id).pipe(\n  Effect.catchTag(\"UserNotFound\", () => Effect.succeed(defaultUser))\n)"
      }
    },
    {
      "id": "catch-tags-pattern",
      "rule": "Error handling with catchTags",
      "example": {
        "description": "Handling multiple error types",
        "bad": "const result = processOrder(order).pipe(\n  Effect.catchAll((error) => {\n    switch (error._tag) {\n      case \"ValidationError\":\n        return Effect.fail(new BadRequest({ message: error.message }))\n      case \"NotFoundError\":\n        return Effect.succeed(defaultOrder)\n      default:\n        return Effect.fail(error)\n    }\n  })\n)",
        "good": "const result = processOrder(order).pipe(\n  Effect.catchTags({\n    ValidationError: (e) => Effect.fail(new BadRequest({ message: e.message })),\n    NotFoundError: () => Effect.succeed(defaultOrder)\n  })\n)"
      }
    },
    {
      "id": "or-else-fallback",
      "rule": "Error fallback patterns",
      "example": {
        "description": "Fallback to alternative",
        "bad": "const result = fetchFromPrimary().pipe(\n  Effect.catchAll(() => fetchFromBackup())\n)",
        "good": "const result = fetchFromPrimary().pipe(\n  Effect.orElse(() => fetchFromBackup())\n)"
      }
    },
    {
      "id": "or-else-succeed",
      "rule": "Error fallback patterns",
      "example": {
        "description": "Fallback to value",
        "bad": "const result = fetchConfig().pipe(\n  Effect.catchAll(() => Effect.succeed(defaultConfig))\n)",
        "good": "const result = fetchConfig().pipe(\n  Effect.orElseSucceed(() => defaultConfig)\n)"
      }
    },
    {
      "id": "timeout-duration",
      "rule": "setTimeout race → Effect.timeout",
      "example": {
        "description": "Adding timeout to operation",
        "bad": "const result = await Promise.race([\n  fetchData(),\n  new Promise((_, reject) =>\n    setTimeout(() => reject(new Error(\"Timeout\")), 5000)\n  )\n])",
        "good": "const result = yield* fetchData().pipe(\n  Effect.timeout(\"5 seconds\")\n)"
      }
    },
    {
      "id": "timeout-fail-typed",
      "rule": "setTimeout race → Effect.timeout",
      "example": {
        "description": "Timeout with typed error",
        "bad": "const withTimeout = async <T>(promise: Promise<T>, ms: number): Promise<T> => {\n  const timeout = new Promise<never>((_, reject) =>\n    setTimeout(() => reject(new Error(\"Timeout\")), ms)\n  )\n  return Promise.race([promise, timeout])\n}",
        "good": "class TimeoutError extends Schema.TaggedError<TimeoutError>()(\"TimeoutError\", {\n  operation: Schema.String,\n}) {}\n\nconst result = yield* fetchData().pipe(\n  Effect.timeoutFail({\n    duration: \"5 seconds\",\n    onTimeout: () => new TimeoutError({ operation: \"fetchData\" })\n  })\n)"
      }
    },
    {
      "id": "retry-exponential",
      "rule": "Manual retry loop → Effect.retry with Schedule",
      "example": {
        "description": "Exponential backoff retry",
        "bad": "let attempts = 0\nlet delay = 100\nwhile (attempts < 5) {\n  try {\n    return await fetchData()\n  } catch {\n    await sleep(delay)\n    delay *= 2\n    attempts++\n  }\n}\nthrow new Error(\"All retries failed\")",
        "good": "const result = yield* fetchData().pipe(\n  Effect.retry(\n    Schedule.exponential(\"100 millis\").pipe(\n      Schedule.jittered,\n      Schedule.compose(Schedule.recurs(5))\n    )\n  )\n)"
      }
    },
    {
      "id": "retry-conditional",
      "rule": "Manual retry loop → Effect.retry with Schedule",
      "example": {
        "description": "Retry only for specific errors",
        "bad": "let attempts = 0\nwhile (attempts < 3) {\n  try {\n    return await fetchData()\n  } catch (e) {\n    if (e.code !== \"NETWORK_ERROR\") throw e\n    attempts++\n  }\n}",
        "good": "const result = yield* fetchData().pipe(\n  Effect.retry({\n    schedule: Schedule.recurs(3),\n    while: (error) =>\n      Match.value(error).pipe(\n        Match.tag(\"NetworkError\", () => true),\n        Match.orElse(() => false)\n      )\n  })\n)"
      }
    },
    {
      "id": "error-accumulation-partition",
      "rule": "Fail-fast errors → Error accumulation",
      "example": {
        "description": "Collect all errors instead of failing fast",
        "bad": "const results = []\nfor (const item of items) {\n  try {\n    results.push(await processItem(item))\n  } catch (e) {\n    // First error stops processing\n    throw e\n  }\n}",
        "good": "// Continue processing and collect all failures\nconst [failures, successes] = yield* Effect.partition(\n  items,\n  (item) => processItem(item)\n)"
      }
    },
    {
      "id": "error-accumulation-either-mode",
      "rule": "Fail-fast errors → Error accumulation",
      "example": {
        "description": "Get Either results for each operation",
        "bad": "const results = await Promise.all(\n  items.map(processItem)\n)  // Fails on first error",
        "good": "// Each result is Either<E, A>\nconst results = yield* Effect.all(\n  Array.map(items, processItem),\n  { mode: \"either\" }\n)"
      }
    },
    {
      "id": "cause-sandbox",
      "rule": "Full error inspection → Effect.sandbox with Cause",
      "example": {
        "description": "Handling defects and expected errors",
        "bad": "try {\n  await Effect.runPromise(program)\n} catch (e) {\n  // Can't distinguish between expected errors and defects\n  console.error(e)\n}",
        "good": "const handled = Effect.sandbox(program).pipe(\n  Effect.catchAll((cause) =>\n    Match.value(cause).pipe(\n      Match.when(Cause.isFailure, () => {\n        // Expected error - recover gracefully\n        return Effect.succeed(fallback)\n      }),\n      Match.when(Cause.isDie, (c) => {\n        // Defect (bug) - log and recover\n        return Effect.logError(\"Unexpected defect\", c).pipe(\n          Effect.as(fallback)\n        )\n      }),\n      Match.when(Cause.isInterrupt, () => {\n        // Interruption - clean shutdown\n        return Effect.succeed(fallback)\n      }),\n      Match.orElse(() => Effect.succeed(fallback))\n    )\n  )\n)"
      }
    },
    {
      "id": "map-error-boundary",
      "rule": "Error transformation at boundaries → Effect.mapError",
      "example": {
        "description": "Transform low-level to domain errors",
        "bad": "const result = await fetch(url).catch((e) => {\n  throw new Error(`API failed: ${e.message}`)\n})",
        "good": "const result = yield* Effect.tryPromise({\n  try: () => fetch(url),\n  catch: (e) => new RawNetworkError({ cause: e })\n}).pipe(\n  Effect.mapError((e) => new ApiError({ url, cause: e }))\n)"
      }
    }
  ]
}
