{
  "id": "native-apis",
  "name": "Native API Replacements",
  "description": "NEVER use native JavaScript APIs that have Effect equivalents. Use Effect's Array module (not array.find), Record module (not Object.keys), Struct module (not spread), Tuple module (not indexing), and Predicate module (not manual &&/||).",
  "patterns": [
    {
      "id": "array-find-to-findfirst",
      "rule": "array.find() → Array.findFirst (returns Option)",
      "example": {
        "description": "Finding element in array",
        "bad": "const admin = users.find((u) => u.role === \"admin\")\nif (admin) {\n  notifyAdmin(admin)\n}",
        "good": "const admin = Array.findFirst(users, (u) => u.role === \"admin\")\nOption.match(admin, {\n  onNone: () => Effect.void,\n  onSome: (a) => notifyAdmin(a)\n})"
      }
    },
    {
      "id": "array-find-default",
      "rule": "array.find() → Array.findFirst (returns Option)",
      "example": {
        "description": "Finding with default",
        "bad": "const found = items.find((i) => i.id === targetId) ?? defaultItem",
        "good": "const found = pipe(\n  Array.findFirst(items, (i) => i.id === targetId),\n  Option.getOrElse(() => defaultItem)\n)"
      }
    },
    {
      "id": "array-index-to-get",
      "rule": "array[index] → Array.get(array, index) (returns Option)",
      "example": {
        "description": "Safe index access",
        "bad": "const first = items[0]\nif (first) {\n  process(first)\n}",
        "good": "pipe(\n  Array.get(items, 0),\n  Option.match({\n    onNone: () => Effect.void,\n    onSome: (item) => process(item)\n  })\n)"
      }
    },
    {
      "id": "array-index-fallback",
      "rule": "array[index] → Array.get(array, index) (returns Option)",
      "example": {
        "description": "Index with fallback",
        "bad": "const item = items[index] ?? defaultItem",
        "good": "const item = pipe(\n  Array.get(items, index),\n  Option.getOrElse(() => defaultItem)\n)"
      }
    },
    {
      "id": "array-head-last",
      "rule": "array[index] → Array.get(array, index) (returns Option)",
      "example": {
        "description": "Head and tail access",
        "bad": "const first = arr[0]\nconst last = arr[arr.length - 1]",
        "good": "const first = Array.head(arr)     // Option<A>\nconst last = Array.last(arr)       // Option<A>"
      }
    },
    {
      "id": "object-keys-to-record",
      "rule": "Object.keys/values/entries → Record.keys/values/toEntries",
      "example": {
        "description": "Iterating object keys",
        "bad": "Object.keys(config).forEach((key) => {\n  console.log(key, config[key])\n})",
        "good": "pipe(\n  Record.toEntries(config),\n  Array.forEach(([key, value]) => console.log(key, value))\n)"
      }
    },
    {
      "id": "object-values-keys",
      "rule": "Object.keys/values/entries → Record.keys/values/toEntries",
      "example": {
        "description": "Getting all values",
        "bad": "const allValues = Object.values(priceMap)\nconst allKeys = Object.keys(priceMap)",
        "good": "const allValues = Record.values(priceMap)\nconst allKeys = Record.keys(priceMap)"
      }
    },
    {
      "id": "object-entries-from-entries",
      "rule": "Object.keys/values/entries → Record.keys/values/toEntries",
      "example": {
        "description": "Converting to entries",
        "bad": "const entries = Object.entries(config)\nconst fromEntries = Object.fromEntries(entries)",
        "good": "const entries = Record.toEntries(config)\nconst fromEntries = Record.fromEntries(entries)"
      }
    },
    {
      "id": "record-index-to-get",
      "rule": "record[key] → Record.get(record, key) (returns Option)",
      "example": {
        "description": "Safe property access",
        "bad": "const price = prices[itemId]\nif (price !== undefined) {\n  calculateTotal(price)\n}",
        "good": "pipe(\n  Record.get(prices, itemId),\n  Option.match({\n    onNone: () => Effect.fail(new ItemNotFound({ itemId })),\n    onSome: (price) => calculateTotal(price)\n  })\n)"
      }
    },
    {
      "id": "record-key-default",
      "rule": "record[key] → Record.get(record, key) (returns Option)",
      "example": {
        "description": "Property with default",
        "bad": "const value = config[key] ?? defaultValue",
        "good": "const value = pipe(\n  Record.get(config, key),\n  Option.getOrElse(() => defaultValue)\n)"
      }
    },
    {
      "id": "predicate-and-or",
      "rule": "Manual && / || for predicates → Predicate.and / Predicate.or / Predicate.not",
      "example": {
        "description": "Combining predicates",
        "bad": "const isValidUser = (u: User) =>\n  u.age >= 18 && u.verified && !u.banned",
        "good": "const isAdult = (u: User) => u.age >= 18\nconst isVerified = (u: User) => u.verified\nconst isBanned = (u: User) => u.banned\n\nconst isValidUser = Predicate.and(\n  isAdult,\n  Predicate.and(isVerified, Predicate.not(isBanned))\n)"
      }
    },
    {
      "id": "predicate-or",
      "rule": "Manual && / || for predicates → Predicate.and / Predicate.or / Predicate.not",
      "example": {
        "description": "Alternative conditions",
        "bad": "const canAccess = (u: User) =>\n  u.role === \"admin\" || u.permissions.includes(\"read\")",
        "good": "const isAdmin = (u: User) => u.role === \"admin\"\nconst hasReadPermission = (u: User) => u.permissions.includes(\"read\")\n\nconst canAccess = Predicate.or(isAdmin, hasReadPermission)"
      }
    },
    {
      "id": "predicate-struct",
      "rule": "Manual && / || for predicates → Predicate.and / Predicate.or / Predicate.not",
      "example": {
        "description": "Struct predicate",
        "bad": "const isValidInput = (input: unknown) =>\n  typeof input === \"object\" &&\n  input !== null &&\n  typeof (input as any).name === \"string\" &&\n  typeof (input as any).age === \"number\"",
        "good": "const isValidInput = Predicate.struct({\n  name: Predicate.isString,\n  age: Predicate.isNumber\n})"
      }
    },
    {
      "id": "spread-to-evolve",
      "rule": "Struct spread for updates → Struct.evolve",
      "example": {
        "description": "Updating specific fields",
        "bad": "const updated = {\n  ...user,\n  age: user.age + 1,\n  name: user.name.toUpperCase()\n}",
        "good": "const updated = Struct.evolve(user, {\n  age: (age) => age + 1,\n  name: (name) => name.toUpperCase()\n})"
      }
    },
    {
      "id": "destructure-to-pick",
      "rule": "Struct spread for updates → Struct.evolve",
      "example": {
        "description": "Picking fields",
        "bad": "const { firstName, lastName } = user\nconst namePart = { firstName, lastName }",
        "good": "const namePart = Struct.pick(user, \"firstName\", \"lastName\")"
      }
    },
    {
      "id": "rest-spread-to-omit",
      "rule": "Struct spread for updates → Struct.evolve",
      "example": {
        "description": "Omitting fields",
        "bad": "const { password, ssn, ...publicUser } = user",
        "good": "const publicUser = Struct.omit(user, \"password\", \"ssn\")"
      }
    },
    {
      "id": "tuple-index-to-get",
      "rule": "tuple[0]/tuple[1] → Tuple.getFirst/getSecond",
      "example": {
        "description": "Tuple element access",
        "bad": "const pair = [\"key\", 42] as const\nconst key = pair[0]\nconst value = pair[1]",
        "good": "const pair = Tuple.make(\"key\", 42)\nconst key = Tuple.getFirst(pair)\nconst value = Tuple.getSecond(pair)"
      }
    },
    {
      "id": "tuple-transform",
      "rule": "tuple[0]/tuple[1] → Tuple.getFirst/getSecond",
      "example": {
        "description": "Tuple transformation",
        "bad": "const transformed = [\n  pair[0].toUpperCase(),\n  pair[1] * 2\n] as const",
        "good": "const transformed = Tuple.mapBoth(pair, {\n  onFirst: (s) => s.toUpperCase(),\n  onSecond: (n) => n * 2\n})"
      }
    },
    {
      "id": "flow-compose-pipeline",
      "rule": "Nested function calls → flow for composing pipelines",
      "example": {
        "description": "Building reusable transformation pipeline",
        "bad": "// Repeated inline logic\nconst processUsers = (users: Array<User>) =>\n  users.filter((u) => u.active).map((u) => u.email)\n\nconst processOrders = (orders: Array<Order>) =>\n  orders.filter((o) => o.active).map((o) => o.total)",
        "good": "import { flow, Array } from \"effect\"\n\n// Reusable pipeline with flow\nconst getActiveEmails = flow(\n  Array.filter((u: User) => u.active),\n  Array.map((u) => u.email)\n)\n\nconst getActiveTotals = flow(\n  Array.filter((o: Order) => o.active),\n  Array.map((o) => o.total)\n)\n\n// Apply the composed pipelines\nconst emails = getActiveEmails(users)\nconst totals = getActiveTotals(orders)"
      }
    },
    {
      "id": "compose-two-functions",
      "rule": "Nested function calls → Function.compose",
      "example": {
        "description": "Composing two functions",
        "bad": "const parseAndValidate = (input: string) =>\n  validate(parse(input))",
        "good": "import { Function } from \"effect\"\n\nconst parseAndValidate = Function.compose(parse, validate)\n// Now: parseAndValidate(input) = validate(parse(input))"
      }
    },
    {
      "id": "identity-passthrough",
      "rule": "No-op functions → Function.identity",
      "example": {
        "description": "Conditional transformation",
        "bad": "const transform = shouldTransform\n  ? myTransform\n  : (x) => x  // Anonymous identity function",
        "good": "import { Function } from \"effect\"\n\nconst transform = shouldTransform\n  ? myTransform\n  : Function.identity  // Standard identity function"
      }
    },
    {
      "id": "constant-fixed-value",
      "rule": "Arrow returning fixed value → Function.constant",
      "example": {
        "description": "Function that always returns same value",
        "bad": "const getDefaultUser = () => defaultUser\nconst alwaysZero = () => 0\nconst noop = () => undefined",
        "good": "import { Function } from \"effect\"\n\nconst getDefaultUser = Function.constant(defaultUser)\nconst alwaysZero = Function.constant(0)\nconst noop = Function.constVoid  // Built-in for () => void"
      }
    },
    {
      "id": "pipe-vs-method-chain",
      "rule": "Method chaining → pipe for consistency",
      "example": {
        "description": "Data transformation pipeline",
        "bad": "// Method chaining (mixes native with Effect)\nconst result = users\n  .filter((u) => u.active)\n  .map((u) => u.email)\n  .slice(0, 10)",
        "good": "import { pipe, Array } from \"effect\"\n\n// Consistent pipe with Effect's Array module\nconst result = pipe(\n  users,\n  Array.filter((u) => u.active),\n  Array.map((u) => u.email),\n  Array.take(10)\n)"
      }
    },
    {
      "id": "filtermap-combined",
      "rule": "filter + map → Array.filterMap in one pass",
      "example": {
        "description": "Filter and transform in single pass",
        "bad": "const validEmails = users\n  .filter((u) => isValidEmail(u.email))\n  .map((u) => u.email)",
        "good": "import { Array, Option } from \"effect\"\n\nconst validEmails = Array.filterMap(users, (u) =>\n  isValidEmail(u.email) ? Option.some(u.email) : Option.none()\n)"
      }
    },
    {
      "id": "groupby-to-array-groupby",
      "rule": "Manual grouping → Array.groupBy",
      "example": {
        "description": "Grouping items by key",
        "bad": "const usersByRole: Record<string, User[]> = {}\nfor (const user of users) {\n  if (!usersByRole[user.role]) {\n    usersByRole[user.role] = []\n  }\n  usersByRole[user.role].push(user)\n}",
        "good": "import { Array } from \"effect\"\n\n// Returns Record<K, NonEmptyArray<A>>\nconst usersByRole = Array.groupBy(users, (u) => u.role)"
      }
    },
    {
      "id": "dedupe-unique",
      "rule": "Set-based deduplication → Array.dedupe",
      "example": {
        "description": "Removing duplicates",
        "bad": "const uniqueIds = [...new Set(ids)]",
        "good": "import { Array } from \"effect\"\n\nconst uniqueIds = Array.dedupe(ids)"
      }
    }
  ]
}
