{
  "id": "conditionals",
  "name": "Conditional Statements",
  "description": "Replace all imperative conditional logic with pattern matching. ZERO if/else, switch/case, or ternary operators are acceptable in Effect code.",
  "patterns": [
    {
      "id": "if-else-to-match-value",
      "rule": "if/else chains → Match.value + Match.when",
      "example": {
        "description": "Role-based access control",
        "bad": "if (user.role === \"admin\") {\n  return \"full access\"\n} else if (user.role === \"user\") {\n  return \"limited access\"\n} else {\n  return \"no access\"\n}",
        "good": "const getAccess = (user: User) =>\n  Match.value(user.role).pipe(\n    Match.when(\"admin\", () => \"full access\"),\n    Match.when(\"user\", () => \"limited access\"),\n    Match.orElse(() => \"no access\")\n  )"
      }
    },
    {
      "id": "if-else-numeric-range",
      "rule": "if/else chains → Match.value + Match.when",
      "example": {
        "description": "Numeric range classification",
        "bad": "if (score >= 90) {\n  return \"A\"\n} else if (score >= 80) {\n  return \"B\"\n} else if (score >= 70) {\n  return \"C\"\n} else {\n  return \"F\"\n}",
        "good": "const getGrade = (score: number) =>\n  Match.value(score).pipe(\n    Match.when((s) => s >= 90, () => \"A\"),\n    Match.when((s) => s >= 80, () => \"B\"),\n    Match.when((s) => s >= 70, () => \"C\"),\n    Match.orElse(() => \"F\")\n  )"
      }
    },
    {
      "id": "if-else-object-properties",
      "rule": "if/else chains → Match.value + Match.when",
      "example": {
        "description": "Multi-condition object matching",
        "bad": "if (order.total > 1000 && order.isPremium) {\n  return 0.25\n} else if (order.total > 1000) {\n  return 0.15\n} else if (order.isPremium) {\n  return 0.10\n} else {\n  return 0\n}",
        "good": "const calculateDiscount = (order: Order) =>\n  Match.value(order).pipe(\n    Match.when({ total: (t) => t > 1000, isPremium: true }, () => 0.25),\n    Match.when({ total: (t) => t > 1000 }, () => 0.15),\n    Match.when({ isPremium: true }, () => 0.10),\n    Match.orElse(() => 0)\n  )"
      }
    },
    {
      "id": "switch-to-match-type",
      "rule": "switch/case statements → Match.type + Match.when or Match.tag",
      "example": {
        "description": "Status string handling",
        "bad": "switch (status) {\n  case \"pending\":\n    return \"Waiting...\"\n  case \"active\":\n    return \"In progress\"\n  case \"completed\":\n    return \"Done!\"\n  case \"failed\":\n    return \"Error occurred\"\n  default:\n    return \"Unknown\"\n}",
        "good": "const processStatus = Match.type<Status>().pipe(\n  Match.when(\"pending\", () => \"Waiting...\"),\n  Match.when(\"active\", () => \"In progress\"),\n  Match.when(\"completed\", () => \"Done!\"),\n  Match.when(\"failed\", () => \"Error occurred\"),\n  Match.exhaustive\n)"
      }
    },
    {
      "id": "switch-to-match-tag",
      "rule": "switch/case statements → Match.type + Match.when or Match.tag",
      "example": {
        "description": "Discriminated union event handling",
        "bad": "switch (event.type) {\n  case \"UserCreated\":\n    return notifyAdmin(event.userId)\n  case \"UserDeleted\":\n    return cleanupData(event.userId)\n  case \"OrderPlaced\":\n    return processOrder(event.orderId)\n  default:\n    throw new Error(\"Unknown event\")\n}",
        "good": "const handleEvent = Match.type<AppEvent>().pipe(\n  Match.tag(\"UserCreated\", (e) => notifyAdmin(e.userId)),\n  Match.tag(\"UserDeleted\", (e) => cleanupData(e.userId)),\n  Match.tag(\"OrderPlaced\", (e) => processOrder(e.orderId)),\n  Match.exhaustive\n)"
      }
    },
    {
      "id": "switch-error-to-status",
      "rule": "switch/case statements → Match.type + Match.when or Match.tag",
      "example": {
        "description": "Error to HTTP status mapping",
        "bad": "function toHttpStatus(error: AppError): number {\n  switch (error._tag) {\n    case \"NotFound\": return 404\n    case \"Unauthorized\": return 401\n    case \"ValidationError\": return 400\n    default: return 500\n  }\n}",
        "good": "const toHttpStatus = Match.type<AppError>().pipe(\n  Match.tag(\"NotFound\", () => 404),\n  Match.tag(\"Unauthorized\", () => 401),\n  Match.tag(\"ValidationError\", () => 400),\n  Match.tag(\"InternalError\", () => 500),\n  Match.exhaustive\n)"
      }
    },
    {
      "id": "ternary-to-match",
      "rule": "Ternary operators (? :) → Match.value + Match.when",
      "example": {
        "description": "Simple boolean condition",
        "bad": "const message = isError ? \"Failed\" : \"Success\"",
        "good": "const message = Match.value(isError).pipe(\n  Match.when(true, () => \"Failed\"),\n  Match.orElse(() => \"Success\")\n)"
      }
    },
    {
      "id": "ternary-complex-to-match",
      "rule": "Ternary operators (? :) → Match.value + Match.when",
      "example": {
        "description": "Nested ternary",
        "bad": "const level = score > 90 ? \"expert\" : score > 70 ? \"intermediate\" : \"beginner\"",
        "good": "const level = Match.value(score).pipe(\n  Match.when((s) => s > 90, () => \"expert\"),\n  Match.when((s) => s > 70, () => \"intermediate\"),\n  Match.orElse(() => \"beginner\")\n)"
      }
    },
    {
      "id": "null-check-to-option-match",
      "rule": "Null checks (if x != null) → Option.match",
      "example": {
        "description": "Null check for display",
        "bad": "if (user != null) {\n  return user.name\n} else {\n  return \"Guest\"\n}",
        "good": "const displayName = Option.match(maybeUser, {\n  onNone: () => \"Guest\",\n  onSome: (user) => user.name\n})"
      }
    },
    {
      "id": "optional-chain-to-option",
      "rule": "Null checks (if x != null) → Option.match",
      "example": {
        "description": "Optional chaining replacement",
        "bad": "const email = user?.email?.toLowerCase() ?? \"no-email\"",
        "good": "const email = pipe(\n  Option.fromNullable(user),\n  Option.flatMap((u) => Option.fromNullable(u.email)),\n  Option.map((e) => e.toLowerCase()),\n  Option.getOrElse(() => \"no-email\")\n)"
      }
    },
    {
      "id": "nullish-coalescing-to-option",
      "rule": "Null checks (if x != null) → Option.match",
      "example": {
        "description": "Nullish coalescing replacement",
        "bad": "const name = user?.name ?? \"Unknown\"",
        "good": "const name = pipe(\n  Option.fromNullable(user),\n  Option.map((u) => u.name),\n  Option.getOrElse(() => \"Unknown\")\n)"
      }
    },
    {
      "id": "null-effectful-to-option",
      "rule": "Null checks (if x != null) → Option.match",
      "example": {
        "description": "Effectful handling of nullable",
        "bad": "if (maybeUser != null) {\n  await sendEmail(maybeUser.email)\n} else {\n  console.log(\"No user to notify\")\n}",
        "good": "Option.match(maybeUser, {\n  onNone: () => Effect.log(\"No user to notify\"),\n  onSome: (user) => sendEmail(user.email)\n})"
      }
    },
    {
      "id": "result-check-to-either-match",
      "rule": "Result/error flag checks → Either.match or Effect.match",
      "example": {
        "description": "Success flag checking",
        "bad": "const result = parseUser(input)\nif (result.success) {\n  process(result.data)\n} else {\n  handleError(result.error)\n}",
        "good": "pipe(\n  Schema.decodeEither(User)(input),\n  Either.match({\n    onLeft: (error) => handleError(error),\n    onRight: (user) => process(user)\n  })\n)"
      }
    },
    {
      "id": "try-result-to-either",
      "rule": "Result/error flag checks → Either.match or Effect.match",
      "example": {
        "description": "Try/catch result object",
        "bad": "try {\n  const validated = validate(data)\n  return { success: true, data: validated }\n} catch (e) {\n  return { success: false, error: e }\n}",
        "good": "const result = Schema.decodeEither(ValidationSchema)(data)\n\nEither.match(result, {\n  onLeft: (error) => Effect.fail(new ValidationError({ cause: error })),\n  onRight: (validated) => Effect.succeed(validated)\n})"
      }
    },
    {
      "id": "effect-result-to-match",
      "rule": "Result/error flag checks → Either.match or Effect.match",
      "example": {
        "description": "Effect success/failure handling",
        "bad": "try {\n  const user = await Effect.runPromise(getUser(id))\n  return { status: \"success\", user }\n} catch (error) {\n  return { status: \"error\", message: error.message }\n}",
        "good": "Effect.match(getUser(id), {\n  onFailure: (error) => ({ status: \"error\", message: error.message }),\n  onSuccess: (user) => ({ status: \"success\", user })\n})"
      }
    },
    {
      "id": "array-empty-check-to-match",
      "rule": "Array empty checks → Array.match",
      "example": {
        "description": "Empty array display",
        "bad": "if (items.length === 0) {\n  return \"No items\"\n} else {\n  return `${items.length} items`\n}",
        "good": "const message = Array.match(items, {\n  onEmpty: () => \"No items\",\n  onNonEmpty: (items) => `${items.length} items`\n})"
      }
    },
    {
      "id": "array-first-element-to-match",
      "rule": "Array empty checks → Array.match",
      "example": {
        "description": "First element with fallback",
        "bad": "const first = items.length > 0 ? items[0] : defaultItem",
        "good": "const first = Array.match(items, {\n  onEmpty: () => defaultItem,\n  onNonEmpty: (arr) => Array.headNonEmpty(arr)\n})"
      }
    },
    {
      "id": "conditional-reassign-to-match",
      "rule": "Conditional variable reassignment → Match.value",
      "example": {
        "description": "Multi-condition assignment",
        "bad": "let result = defaultValue\nif (condition1) {\n  result = value1\n} else if (condition2) {\n  result = value2\n}",
        "good": "const result = Match.value({ condition1, condition2 }).pipe(\n  Match.when({ condition1: true }, () => value1),\n  Match.when({ condition2: true }, () => value2),\n  Match.orElse(() => defaultValue)\n)"
      }
    }
  ]
}
