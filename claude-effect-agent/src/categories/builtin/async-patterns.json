{
  "id": "async-patterns",
  "name": "Async/Promise Patterns",
  "patterns": [
    {
      "id": "async-await-to-effect-gen",
      "rule": "async/await mixed with Effect → Effect.gen with yield*",
      "example": {
        "description": "Converting async function",
        "bad": "const fetchAndProcess = async (id: string) => {\n  const user = await getUser(id)\n  const orders = await getOrders(user.id)\n  return { user, orders }\n}\n\n// Mixed in Effect\nconst program = Effect.gen(function* () {\n  const result = await fetchAndProcess(\"123\") // DON'T DO THIS\n  return result\n})",
        "good": "const fetchAndProcess = (id: string) =>\n  Effect.gen(function* () {\n    const user = yield* getUser(id)\n    const orders = yield* getOrders(user.id)\n    return { user, orders }\n  })\n\n// Pure Effect composition\nconst program = Effect.gen(function* () {\n  const result = yield* fetchAndProcess(\"123\")\n  return result\n})"
      }
    },
    {
      "id": "wrap-external-async",
      "rule": "async/await mixed with Effect → Effect.gen with yield*",
      "example": {
        "description": "Wrapping external async library",
        "bad": "import { externalLib } from \"some-lib\"\n\nconst useLibrary = Effect.gen(function* () {\n  // Mixing async/await with Effect - BAD\n  const result = await externalLib.doSomething()\n  return result\n})",
        "good": "import { externalLib } from \"some-lib\"\n\n// Wrap at the boundary\nconst doSomething = Effect.tryPromise({\n  try: () => externalLib.doSomething(),\n  catch: (e) => new LibraryError({ cause: e })\n})\n\n// Use the wrapped Effect\nconst useLibrary = Effect.gen(function* () {\n  const result = yield* doSomething\n  return result\n})"
      }
    },
    {
      "id": "promise-all-to-effect-all",
      "rule": "Promise.all → Effect.all",
      "example": {
        "description": "Parallel operations",
        "bad": "const [user, orders, settings] = await Promise.all([\n  getUser(id),\n  getOrders(id),\n  getSettings(id),\n])",
        "good": "const [user, orders, settings] = yield* Effect.all([\n  getUser(id),\n  getOrders(id),\n  getSettings(id),\n])"
      }
    },
    {
      "id": "promise-all-concurrency",
      "rule": "Promise.all → Effect.all",
      "example": {
        "description": "Parallel with concurrency limit",
        "bad": "// No easy way to limit concurrency with Promise.all\nconst results = await Promise.all(items.map(processItem))",
        "good": "// Effect.all with concurrency option\nconst results = yield* Effect.all(\n  Array.map(items, processItem),\n  { concurrency: 5 }\n)"
      }
    },
    {
      "id": "promise-all-named",
      "rule": "Promise.all → Effect.all",
      "example": {
        "description": "Named parallel results",
        "bad": "const results = await Promise.all([getUser(id), getOrders(id)])\nconst user = results[0]\nconst orders = results[1]",
        "good": "const { user, orders } = yield* Effect.all({\n  user: getUser(id),\n  orders: getOrders(id),\n})"
      }
    },
    {
      "id": "promise-chain-to-pipe",
      "rule": "Promise chains → Effect.flatMap or pipe",
      "example": {
        "description": "Sequential async operations",
        "bad": "getUser(id)\n  .then((user) => getOrders(user.id))\n  .then((orders) => processOrders(orders))\n  .then((result) => saveResult(result))\n  .catch((error) => handleError(error))",
        "good": "pipe(\n  getUser(id),\n  Effect.flatMap((user) => getOrders(user.id)),\n  Effect.flatMap((orders) => processOrders(orders)),\n  Effect.flatMap((result) => saveResult(result)),\n  Effect.catchAll((error) => handleError(error))\n)"
      }
    },
    {
      "id": "promise-chain-transform",
      "rule": "Promise chains → Effect.flatMap or pipe",
      "example": {
        "description": "Promise chain with transformation",
        "bad": "fetchData()\n  .then((data) => data.items)\n  .then((items) => items.filter((i) => i.active))\n  .then((active) => active.map((i) => i.id))",
        "good": "pipe(\n  fetchData(),\n  Effect.map((data) => data.items),\n  Effect.map(Array.filter((i) => i.active)),\n  Effect.map(Array.map((i) => i.id))\n)"
      }
    },
    {
      "id": "await-to-yield-star",
      "rule": "await in Effect.gen → yield* (except at boundaries)",
      "example": {
        "description": "Correct generator usage",
        "bad": "const program = Effect.gen(function* () {\n  const user = await getUser(id)      // Wrong: using await\n  const orders = yield getOrders(id)  // Wrong: missing *\n  return { user, orders }\n})",
        "good": "const program = Effect.gen(function* () {\n  const user = yield* getUser(id)      // Correct: yield*\n  const orders = yield* getOrders(id)  // Correct: yield*\n  return { user, orders }\n})"
      }
    },
    {
      "id": "boundary-main-entry",
      "rule": "await in Effect.gen → yield* (except at boundaries)",
      "example": {
        "description": "Boundary: main entry point",
        "bad": "// Trying to use Effect in async context badly\nasync function main() {\n  const result = yield* myEffect  // Can't use yield* outside Effect.gen\n}",
        "good": "// At application boundary, use runPromise\nconst main = async () => {\n  const result = await Effect.runPromise(\n    myEffect.pipe(Effect.provide(AppLive))\n  )\n  console.log(result)\n}\n\n// Or for CLI tools\nEffect.runPromise(\n  myEffect.pipe(Effect.provide(AppLive))\n).then(console.log).catch(console.error)"
      }
    },
    {
      "id": "boundary-http-handler",
      "rule": "await in Effect.gen → yield* (except at boundaries)",
      "example": {
        "description": "Boundary: HTTP handler",
        "bad": "// Express handler mixing styles\napp.get(\"/users/:id\", async (req, res) => {\n  const user = yield* getUser(req.params.id)  // Won't work\n  res.json(user)\n})",
        "good": "// Convert Effect to Promise at HTTP boundary\napp.get(\"/users/:id\", async (req, res) => {\n  const result = await Effect.runPromise(\n    getUser(req.params.id).pipe(\n      Effect.provide(AppLive),\n      Effect.either\n    )\n  )\n\n  Either.match(result, {\n    onLeft: (error) => res.status(500).json({ error: error.message }),\n    onRight: (user) => res.json(user)\n  })\n})"
      }
    }
  ]
}
