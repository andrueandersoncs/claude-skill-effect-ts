{
  "id": "imperative",
  "name": "Loops & Mutation",
  "description": "NEVER use for/while/do-while loops or mutate variables. Use Effect's Array/Record modules for data transformation, Effect.forEach for effectful iteration, and recursion for complex traversals. All data transformations must be immutable.",
  "rules": [
    {
      "rule": "Never use for/while/do loops; use Array.map/filter/reduce or Effect.forEach",
      "example": {
        "description": "Effectful iteration",
        "bad": "const results = []\nfor (const item of items) {\n  const result = await processItem(item)\n  results.push(result)\n}",
        "good": "const results = yield* Effect.forEach(items, processItem)"
      }
    },
    {
      "rule": "Never use for...of/for...in; use Array module functions",
      "example": {
        "description": "Conditional accumulation",
        "bad": "let total = 0\nfor (const order of orders) {\n  if (order.status === \"completed\") {\n    total += order.amount\n  }\n}",
        "good": "const total = pipe(\n  orders,\n  Array.filter((o) => o.status === \"completed\"),\n  Array.reduce(0, (acc, o) => acc + o.amount)\n)"
      }
    },
    {
      "rule": "Never mutate variables (let, push, pop, splice); use immutable operations",
      "example": {
        "description": "Array splice/modification",
        "bad": "const arr = [...items]\narr.splice(2, 1)  // Remove at index 2\narr.splice(1, 0, newItem)  // Insert at index 1",
        "good": "const removed = pipe(\n  items,\n  Array.remove(2)\n)\nconst inserted = pipe(\n  items,\n  Array.insertAt(1, newItem),\n  Option.getOrElse(() => items)\n)"
      }
    },
    {
      "rule": "Never reassign variables; use functional transformation",
      "example": {
        "description": "Building object with mutation",
        "bad": "const obj: Record<string, number> = {}\nfor (const item of items) {\n  obj[item.key] = item.value\n}",
        "good": "const obj = pipe(\n  items,\n  Array.map((item) => [item.key, item.value] as const),\n  Record.fromEntries\n)"
      }
    },
    {
      "rule": "Never use imperative loops for tree traversal; use recursion with Effect",
      "example": {
        "description": "Recursive Effect processing",
        "bad": "async function processTree(node) {\n  if (node.children.length === 0) {\n    return await processLeaf(node)\n  }\n  const results = []\n  for (const child of node.children) {\n    results.push(await processTree(child))\n  }\n  return combineResults(results)\n}",
        "good": "const processTree = (node: TreeNode): Effect.Effect<Result> =>\n  Array.match(node.children, {\n    onEmpty: () => processLeaf(node),\n    onNonEmpty: (children) =>\n      Effect.forEach(children, processTree).pipe(\n        Effect.flatMap(combineResults)\n      )\n  })"
      }
    },
    {
      "rule": "Never use manual batching loops; use Effect.all with concurrency",
      "example": {
        "description": "Limited concurrency",
        "bad": "// Complex manual batching with Promise.all\nconst batchSize = 5\nfor (let i = 0; i < items.length; i += batchSize) {\n  const batch = items.slice(i, i + batchSize)\n  await Promise.all(batch.map(processItem))\n}",
        "good": "const results = yield* Effect.all(\n  Array.map(items, processItem),\n  { concurrency: 5 }\n)"
      }
    },
    {
      "rule": "Never use manual batching for large sequences; use Stream",
      "example": {
        "description": "Chunked processing with concurrency",
        "bad": "// Manual batching\nconst batchSize = 100\nfor (let i = 0; i < items.length; i += batchSize) {\n  const batch = items.slice(i, i + batchSize)\n  await Promise.all(batch.map(processItem))\n}",
        "good": "import { Stream } from \"effect\"\n\nconst results = yield* Stream.fromIterable(items).pipe(\n  Stream.grouped(100),\n  Stream.mapEffect((batch) =>\n    Effect.all(Array.map(batch, processItem), { concurrency: \"unbounded\" })\n  ),\n  Stream.runCollect\n)"
      }
    },
    {
      "rule": "Never use nested for loops; use Array.flatMap",
      "example": {
        "description": "Flattening nested arrays",
        "bad": "const allTags = []\nfor (const post of posts) {\n  for (const tag of post.tags) {\n    allTags.push(tag)\n  }\n}",
        "good": "import { Array } from \"effect\"\n\nconst allTags = Array.flatMap(posts, (post) => post.tags)"
      }
    },
    {
      "rule": "Never filter twice with opposite conditions; use Array.partition",
      "example": {
        "description": "Splitting array by condition",
        "bad": "const minors = users.filter((u) => u.age < 18)\nconst adults = users.filter((u) => u.age >= 18)",
        "good": "import { Array } from \"effect\"\n\n// Single pass, returns [excluded, satisfying]\nconst [minors, adults] = Array.partition(users, (u) => u.age >= 18)"
      }
    }
  ]
}
