{
  "id": "services",
  "name": "Services & Layers",
  "description": "NEVER call external APIs, databases, or file systems directly. ALL effectful dependencies MUST be behind a Context.Tag service. Every service MUST have both a *Live and *Test layer implementation for full testability.",
  "rules": [
    {
      "rule": "Never call external APIs directly; use a Context.Tag service",
      "example": {
        "description": "HTTP API call",
        "bad": "const getUser = (id: string) =>\n  Effect.tryPromise(() =>\n    fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n  )\n\n// Used directly in business logic\nconst processUser = (id: string) =>\n  Effect.gen(function* () {\n    const user = yield* getUser(id) // Direct API call - untestable!\n    return processData(user)\n  })",
        "good": "// Define service interface\nclass UserApi extends Context.Tag(\"UserApi\")<\n  UserApi,\n  {\n    readonly getUser: (id: string) => Effect.Effect<User, ApiError>\n    readonly updateUser: (user: User) => Effect.Effect<void, ApiError>\n  }\n>() {}\n\n// Use service in business logic\nconst processUser = (id: string) =>\n  Effect.gen(function* () {\n    const api = yield* UserApi\n    const user = yield* api.getUser(id)\n    return processData(user)\n  })\n\n// Live implementation\nconst UserApiLive = Layer.succeed(UserApi, {\n  getUser: (id) =>\n    Effect.tryPromise({\n      try: () => fetch(`https://api.example.com/users/${id}`).then((r) => r.json()),\n      catch: (e) => new ApiError({ cause: e })\n    }),\n  updateUser: (user) =>\n    Effect.tryPromise({\n      try: () => fetch(`https://api.example.com/users/${user.id}`, {\n        method: \"PUT\",\n        body: JSON.stringify(user)\n      }),\n      catch: (e) => new ApiError({ cause: e })\n    })\n})\n\n// Test implementation\nconst UserApiTest = Layer.succeed(UserApi, {\n  getUser: (id) => Effect.succeed({ id, name: \"Test User\", email: \"test@test.com\" }),\n  updateUser: () => Effect.void\n})"
      }
    },
    {
      "rule": "Never access database directly; use a Context.Tag repository",
      "example": {
        "description": "Database operations",
        "bad": "import { db } from \"./database\"\n\nconst findUser = (id: string) =>\n  Effect.tryPromise(() => db.query(\"SELECT * FROM users WHERE id = ?\", [id]))\n\nconst saveUser = (user: User) =>\n  Effect.tryPromise(() => db.query(\"INSERT INTO users VALUES (?)\", [user]))",
        "good": "// Repository interface\nclass UserRepository extends Context.Tag(\"UserRepository\")<\n  UserRepository,\n  {\n    readonly findById: (id: UserId) => Effect.Effect<User, UserNotFound>\n    readonly findByEmail: (email: string) => Effect.Effect<User, UserNotFound>\n    readonly save: (user: User) => Effect.Effect<void>\n    readonly delete: (id: UserId) => Effect.Effect<void>\n  }\n>() {}\n\n// Live implementation with real database\nconst UserRepositoryLive = Layer.effect(\n  UserRepository,\n  Effect.gen(function* () {\n    const db = yield* Database\n    return {\n      findById: (id) =>\n        Effect.tryPromise({\n          try: () => db.query(\"SELECT * FROM users WHERE id = ?\", [id]),\n          catch: () => new UserNotFound({ userId: id })\n        }),\n      findByEmail: (email) =>\n        Effect.tryPromise({\n          try: () => db.query(\"SELECT * FROM users WHERE email = ?\", [email]),\n          catch: () => new UserNotFound({ userId: email })\n        }),\n      save: (user) =>\n        Effect.tryPromise({\n          try: () => db.query(\"INSERT INTO users VALUES (?)\", [user]),\n          catch: (e) => new DatabaseError({ cause: e })\n        }),\n      delete: (id) =>\n        Effect.tryPromise({\n          try: () => db.query(\"DELETE FROM users WHERE id = ?\", [id]),\n          catch: (e) => new DatabaseError({ cause: e })\n        })\n    }\n  })\n)\n\n// Test implementation with in-memory store\nconst UserRepositoryTest = Layer.succeed(UserRepository, {\n  findById: (id) => Effect.succeed({ id, name: \"Test\", email: \"test@test.com\" }),\n  findByEmail: (email) => Effect.succeed({ id: \"1\", name: \"Test\", email }),\n  save: () => Effect.void,\n  delete: () => Effect.void\n})"
      }
    },
    {
      "rule": "Never use direct file I/O; use a Context.Tag service",
      "example": {
        "description": "File system operations",
        "bad": "import * as fs from \"fs/promises\"\n\nconst readConfig = () =>\n  Effect.tryPromise(() => fs.readFile(\"config.json\", \"utf-8\"))\n\nconst writeLog = (message: string) =>\n  Effect.tryPromise(() => fs.appendFile(\"app.log\", message))",
        "good": "// FileSystem service\nclass FileSystem extends Context.Tag(\"FileSystem\")<\n  FileSystem,\n  {\n    readonly readFile: (path: string) => Effect.Effect<string, FileError>\n    readonly writeFile: (path: string, content: string) => Effect.Effect<void, FileError>\n    readonly appendFile: (path: string, content: string) => Effect.Effect<void, FileError>\n    readonly exists: (path: string) => Effect.Effect<boolean>\n  }\n>() {}\n\n// Live implementation\nconst FileSystemLive = Layer.succeed(FileSystem, {\n  readFile: (path) =>\n    Effect.tryPromise({\n      try: () => fs.readFile(path, \"utf-8\"),\n      catch: (e) => new FileError({ path, cause: e })\n    }),\n  writeFile: (path, content) =>\n    Effect.tryPromise({\n      try: () => fs.writeFile(path, content),\n      catch: (e) => new FileError({ path, cause: e })\n    }),\n  appendFile: (path, content) =>\n    Effect.tryPromise({\n      try: () => fs.appendFile(path, content),\n      catch: (e) => new FileError({ path, cause: e })\n    }),\n  exists: (path) =>\n    Effect.tryPromise({\n      try: () => fs.access(path).then(() => true).catch(() => false),\n      catch: () => false\n    })\n})\n\n// Test implementation with virtual file system\nconst FileSystemTest = (files: Map<string, string>) =>\n  Layer.succeed(FileSystem, {\n    readFile: (path) =>\n      pipe(\n        Option.fromNullable(files.get(path)),\n        Option.match({\n          onNone: () => Effect.fail(new FileError({ path, cause: \"Not found\" })),\n          onSome: (content) => Effect.succeed(content)\n        })\n      ),\n    writeFile: (path, content) =>\n      Effect.sync(() => { files.set(path, content) }),\n    appendFile: (path, content) =>\n      Effect.sync(() => {\n        const existing = files.get(path) ?? \"\"\n        files.set(path, existing + content)\n      }),\n    exists: (path) =>\n      Effect.succeed(files.has(path))\n  })"
      }
    },
    {
      "rule": "Never create a service without both *Live and *Test layers",
      "example": {
        "description": "Complete layer setup",
        "bad": "// Only has live implementation\nconst EmailServiceLive = Layer.succeed(EmailService, {\n  send: (email) => sendRealEmail(email)\n})\n\n// Tests hit real email service!\nit.effect(\"should send welcome email\", () =>\n  Effect.gen(function* () {\n    yield* sendWelcomeEmail(user)\n  }).pipe(Effect.provide(EmailServiceLive))\n)",
        "good": "// Live implementation\nconst EmailServiceLive = Layer.succeed(EmailService, {\n  send: (email) => sendRealEmail(email)\n})\n\n// Test implementation that captures sent emails\nconst EmailServiceTest = (sentEmails: Array<Email> = []) =>\n  Layer.succeed(EmailService, {\n    send: (email) =>\n      Effect.sync(() => {\n        sentEmails.push(email)\n      })\n  })\n\n// Test can verify email behavior without sending\nit.effect(\"should send welcome email\", () => {\n  const sentEmails: Email[] = []\n  return Effect.gen(function* () {\n    yield* sendWelcomeEmail(user)\n    expect(sentEmails).toHaveLength(1)\n    expect(sentEmails[0].to).toBe(user.email)\n    expect(sentEmails[0].subject).toContain(\"Welcome\")\n  }).pipe(Effect.provide(EmailServiceTest(sentEmails)))\n})"
      }
    },
    {
      "rule": "Never create services inline; use Layer.effect or Layer.succeed",
      "example": {
        "description": "Service with dependencies",
        "bad": "// Creating service implementation inline\nconst program = Effect.gen(function* () {\n  const db = yield* Database\n  const cache = yield* Cache\n\n  // Business logic mixed with service creation\n  const user = yield* db.query(\"...\")\n  yield* cache.set(user.id, user)\n})",
        "good": "// UserService depends on Database and Cache\nconst UserServiceLive = Layer.effect(\n  UserService,\n  Effect.gen(function* () {\n    const db = yield* Database\n    const cache = yield* Cache\n\n    return {\n      getUser: (id) =>\n        Effect.gen(function* () {\n          // Check cache first\n          const cached = yield* cache.get(id)\n          if (Option.isSome(cached)) {\n            return cached.value\n          }\n\n          // Fetch from DB and cache\n          const user = yield* db.query(\"SELECT * FROM users WHERE id = ?\", [id])\n          yield* cache.set(id, user)\n          return user\n        }),\n      // ... other methods\n    }\n  })\n)\n\n// Layer composition handles dependencies\nconst AppLive = UserServiceLive.pipe(\n  Layer.provide(Layer.mergeAll(DatabaseLive, CacheLive))\n)"
      }
    },
    {
      "rule": "Never call third-party SDKs directly; wrap in a Context.Tag service",
      "example": {
        "description": "Third-party SDK usage (Stripe, SendGrid, AWS, etc.)",
        "bad": "import Stripe from \"stripe\"\n\nconst stripe = new Stripe(process.env.STRIPE_KEY)\n\n// Direct SDK call in business logic - untestable!\nconst processPayment = (amount: number) =>\n  Effect.tryPromise(() =>\n    stripe.charges.create({ amount, currency: \"usd\" })\n  )",
        "good": "import Stripe from \"stripe\"\n\n// Define service interface\nclass PaymentGateway extends Context.Tag(\"PaymentGateway\")<\n  PaymentGateway,\n  {\n    readonly charge: (amount: number, currency: string) => Effect.Effect<ChargeResult, PaymentError>\n    readonly refund: (chargeId: string) => Effect.Effect<void, RefundError>\n  }\n>() {}\n\n// Live implementation with real Stripe\nconst PaymentGatewayLive = Layer.effect(\n  PaymentGateway,\n  Effect.gen(function* () {\n    const config = yield* Config.string(\"STRIPE_KEY\")\n    const stripe = new Stripe(config)\n\n    return {\n      charge: (amount, currency) =>\n        Effect.tryPromise({\n          try: () => stripe.charges.create({ amount, currency }),\n          catch: (e) => new PaymentError({ cause: e })\n        }),\n      refund: (chargeId) =>\n        Effect.tryPromise({\n          try: () => stripe.refunds.create({ charge: chargeId }),\n          catch: (e) => new RefundError({ cause: e })\n        })\n    }\n  })\n)\n\n// Test implementation - no real Stripe calls\nconst PaymentGatewayTest = Layer.succeed(PaymentGateway, {\n  charge: (amount, currency) =>\n    Effect.succeed({ id: \"ch_test\", amount, currency, status: \"succeeded\" }),\n  refund: () => Effect.void\n})\n\n// Business logic uses service - fully testable\nconst processPayment = (amount: number) =>\n  Effect.gen(function* () {\n    const gateway = yield* PaymentGateway\n    return yield* gateway.charge(amount, \"usd\")\n  })"
      }
    },
    {
      "rule": "Never provide services ad-hoc; compose layers with Layer.mergeAll/provide",
      "example": {
        "description": "Building application layer stack",
        "bad": "// Providing services ad-hoc throughout codebase\nconst result = yield* myEffect.pipe(\n  Effect.provideService(Logger, loggerImpl),\n  Effect.provideService(UserRepo, userRepoImpl),\n  Effect.provideService(EmailService, emailImpl)\n)",
        "good": "// Compose layers bottom-up in a dedicated module\n\n// Infrastructure layer (no dependencies)\nconst InfraLive = Layer.mergeAll(\n  DatabaseLive,\n  HttpClientLive,\n  LoggerLive\n)\n\n// Repository layer (depends on Infrastructure)\nconst RepositoriesLive = Layer.mergeAll(\n  UserRepositoryLive,\n  OrderRepositoryLive\n).pipe(Layer.provide(InfraLive))\n\n// Service layer (depends on Repositories)\nconst ServicesLive = Layer.mergeAll(\n  UserServiceLive,\n  OrderServiceLive,\n  EmailServiceLive\n).pipe(Layer.provide(RepositoriesLive))\n\n// Application entry point\nexport const AppLive = ServicesLive\n\n// Usage at boundary\nEffect.runPromise(program.pipe(Effect.provide(AppLive)))"
      }
    },
    {
      "rule": "Never use stateless test mocks; use Layer.effect with Ref for state",
      "example": {
        "description": "Repository test layer maintaining state",
        "bad": "// Stateless mock - can't test save then find\nconst UserRepositoryTest = Layer.succeed(UserRepository, {\n  findById: (id) => Effect.succeed({ id, name: \"Fixed\" }),\n  save: () => Effect.void,\n})",
        "good": "// Stateful mock with Ref - tests can save then find\nconst UserRepositoryTest = Layer.effect(\n  UserRepository,\n  Effect.gen(function* () {\n    const store = yield* Ref.make<Map<string, User>>(new Map())\n\n    return {\n      findById: (id: string) =>\n        Effect.gen(function* () {\n          const users = yield* Ref.get(store)\n          return yield* pipe(\n            Option.fromNullable(users.get(id)),\n            Option.match({\n              onNone: () => Effect.fail(new UserNotFound({ userId: id })),\n              onSome: Effect.succeed\n            })\n          )\n        }).pipe(Effect.flatten),\n\n      save: (user: User) =>\n        Ref.update(store, (m) => new Map(m).set(user.id, user)),\n\n      delete: (id: string) =>\n        Ref.update(store, (m) => {\n          const next = new Map(m)\n          next.delete(id)\n          return next\n        })\n    }\n  })\n)"
      }
    }
  ]
}
