[
	{
		"ruleId": "rule-001",
		"category": "comments",
		"originalName": "branded-type-definition",
		"rule": "Never add JSDoc comments that merely restate the type definition; the types are self-documenting",
		"example": "Branded type definition"
	},
	{
		"ruleId": "rule-002",
		"category": "comments",
		"originalName": "code-organization",
		"rule": "Never add section marker comments; use file organization and clear naming instead",
		"example": "Code organization"
	},
	{
		"ruleId": "rule-003",
		"category": "comments",
		"originalName": "effect-pipeline",
		"rule": "Never add inline comments for obvious Effect patterns; Effect code is self-documenting",
		"example": "Effect pipeline"
	},
	{
		"ruleId": "rule-004",
		"category": "comments",
		"originalName": "function-documentation",
		"rule": "Never add JSDoc @param/@returns that just repeat the type signature",
		"example": "Function documentation"
	},
	{
		"ruleId": "rule-005",
		"category": "comments",
		"originalName": "function-implementation",
		"rule": "Never add comments describing WHAT code does; the code itself shows that",
		"example": "Function implementation"
	},
	{
		"ruleId": "rule-006",
		"category": "comments",
		"originalName": "legitimate-why-comment",
		"rule": "Only add comments explaining WHY when the reason isn't obvious from context",
		"example": "Legitimate why comment"
	},
	{
		"ruleId": "rule-007",
		"category": "comments",
		"originalName": "naming-over-commenting",
		"rule": "Never add comments that could be replaced by better variable or function names",
		"example": "Naming over commenting"
	},
	{
		"ruleId": "rule-008",
		"category": "comments",
		"originalName": "todo-comments",
		"rule": "Never add TODO comments without actionable context; either fix it or remove it",
		"example": "TODO comments"
	},
	{
		"ruleId": "rule-001",
		"category": "imperative",
		"originalName": "array-splice-modification",
		"rule": "Never mutate variables (let, push, pop, splice); use immutable operations",
		"example": "Array splice/modification"
	},
	{
		"ruleId": "rule-002",
		"category": "imperative",
		"originalName": "building-object-mutation",
		"rule": "Never reassign variables; use functional transformation",
		"example": "Building object with mutation"
	},
	{
		"ruleId": "rule-003",
		"category": "imperative",
		"originalName": "chunked-processing",
		"rule": "Never use manual batching for large sequences; use Stream",
		"example": "Chunked processing with concurrency"
	},
	{
		"ruleId": "rule-004",
		"category": "imperative",
		"originalName": "conditional-accumulation",
		"rule": "Never use for...of/for...in; use Array module functions",
		"example": "Conditional accumulation"
	},
	{
		"ruleId": "rule-005",
		"category": "imperative",
		"originalName": "effectful-iteration",
		"rule": "Never use for/while/do loops; use Array.map/filter/reduce or Effect.forEach",
		"example": "Effectful iteration"
	},
	{
		"ruleId": "rule-006",
		"category": "imperative",
		"originalName": "flattening-nested-arrays",
		"rule": "Never use nested for loops; use Array.flatMap",
		"example": "Flattening nested arrays"
	},
	{
		"ruleId": "rule-007",
		"category": "imperative",
		"originalName": "limited-concurrency",
		"rule": "Never use manual batching loops; use Effect.all with concurrency",
		"example": "Limited concurrency"
	},
	{
		"ruleId": "rule-008",
		"category": "imperative",
		"originalName": "recursive-effect-processing",
		"rule": "Never use imperative loops for tree traversal; use recursion with Effect",
		"example": "Recursive Effect processing"
	},
	{
		"ruleId": "rule-009",
		"category": "imperative",
		"originalName": "splitting-array-by-condition",
		"rule": "Never filter twice with opposite conditions; use Array.partition",
		"example": "Splitting array by condition"
	},
	{
		"ruleId": "rule-001",
		"category": "conditionals",
		"originalName": "array-empty-check",
		"rule": "Never use array empty checks; use Array.match",
		"example": "First element with fallback"
	},
	{
		"ruleId": "rule-002",
		"category": "conditionals",
		"originalName": "match-literal-union",
		"rule": "Never use multiple OR conditions (||); define a Schema union with Schema.Literal and use Match.when with Schema.is",
		"example": "Matching any of several values with Schema.Literal union"
	},
	{
		"ruleId": "rule-003",
		"category": "conditionals",
		"originalName": "match-struct-conditions",
		"rule": "Never use combined AND conditions (&&); define a Schema.Struct capturing all conditions and use Match.when with Schema.is",
		"example": "Matching multiple conditions with Schema.Struct"
	},
	{
		"ruleId": "rule-004",
		"category": "conditionals",
		"originalName": "multi-condition-assignment",
		"rule": "Never use conditional variable reassignment; define Schema types and use Match.when with Schema.is",
		"example": "Multi-condition assignment with Schema-defined conditions"
	},
	{
		"ruleId": "rule-005",
		"category": "conditionals",
		"originalName": "multi-condition-matching",
		"rule": "Never use if/else chains; define Schema types for each condition and use Match.when with Schema.is",
		"example": "Multi-condition object matching with Schema-defined predicates"
	},
	{
		"ruleId": "rule-006",
		"category": "conditionals",
		"originalName": "nullable-option-match",
		"rule": "Never use null checks (if x != null); use Option.match",
		"example": "Effectful handling of nullable"
	},
	{
		"ruleId": "rule-007",
		"category": "conditionals",
		"originalName": "numeric-classification",
		"rule": "Never use negative conditions in if statements; define Schema types for each case and use Match.when with Schema.is",
		"example": "Numeric classification with Schema-defined ranges"
	},
	{
		"ruleId": "rule-008",
		"category": "conditionals",
		"originalName": "result-effect-match",
		"rule": "Never use result/error flag checks; use Either.match or Effect.match with Schema.TaggedClass",
		"example": "Effect success/failure handling with Schema-defined result types"
	},
	{
		"ruleId": "rule-009",
		"category": "conditionals",
		"originalName": "switch-to-match-tag",
		"rule": "Never use switch/case statements; use Match.type with Match.tag for discriminated unions",
		"example": "Discriminated union event handling"
	},
	{
		"ruleId": "rule-010",
		"category": "conditionals",
		"originalName": "ternary-to-match",
		"rule": "Never use ternary operators; define Schema types for each range and use Match.when with Schema.is",
		"example": "Nested ternary replaced with Schema-defined score ranges"
	},
	{
		"ruleId": "rule-001",
		"category": "async",
		"originalName": "callback-api",
		"rule": "Never use new Promise(); use Effect.async for callback-based APIs",
		"example": "Converting callback-based API"
	},
	{
		"ruleId": "rule-002",
		"category": "async",
		"originalName": "generator-yield",
		"rule": "Never use yield or await in Effect.gen; use yield*",
		"example": "Correct generator usage"
	},
	{
		"ruleId": "rule-003",
		"category": "async",
		"originalName": "http-handler-boundary",
		"rule": "Never use Effect.runPromise except at application boundaries",
		"example": "HTTP handler (boundary OK)"
	},
	{
		"ruleId": "rule-004",
		"category": "async",
		"originalName": "parallel-results",
		"rule": "Never use Promise.all; use Effect.all",
		"example": "Named parallel results"
	},
	{
		"ruleId": "rule-005",
		"category": "async",
		"originalName": "promise-chain",
		"rule": "Never use Promise chains (.then); use pipe with Effect.map/flatMap",
		"example": "Promise chain with transformation"
	},
	{
		"ruleId": "rule-006",
		"category": "async",
		"originalName": "race-operations",
		"rule": "Never use Promise.race; use Effect.race or Effect.raceAll",
		"example": "Racing multiple operations"
	},
	{
		"ruleId": "rule-007",
		"category": "async",
		"originalName": "repeated-execution",
		"rule": "Never use setTimeout/setInterval; use Effect.sleep and Schedule",
		"example": "Repeated execution"
	},
	{
		"ruleId": "rule-008",
		"category": "async",
		"originalName": "wrap-external-async",
		"rule": "Never use async functions; use Effect.gen with yield*",
		"example": "Wrapping external async library"
	},
	{
		"ruleId": "rule-001",
		"category": "testing",
		"originalName": "arbitrary-responses",
		"rule": "Never stub methods as \"not implemented\"; use Arbitrary-generated responses",
		"example": "Anti-pattern: stubbing methods as not implemented"
	},
	{
		"ruleId": "rule-002",
		"category": "testing",
		"originalName": "arbitrary-test-layer",
		"rule": "Never hard-code values in test layers; use Arbitrary-generated values",
		"example": "Test layer with hard-coded responses"
	},
	{
		"ruleId": "rule-003",
		"category": "testing",
		"originalName": "effect-exit",
		"rule": "Never use try/catch for error assertions; use Effect.exit",
		"example": "Asserting on error type and data"
	},
	{
		"ruleId": "rule-004",
		"category": "testing",
		"originalName": "effect-vitest-imports",
		"rule": "Never import from vitest directly; use @effect/vitest",
		"example": "Test file imports"
	},
	{
		"ruleId": "rule-005",
		"category": "testing",
		"originalName": "equality-testers",
		"rule": "Never skip addEqualityTesters(); call it for Effect type equality",
		"example": "Setup for Effect equality assertions"
	},
	{
		"ruleId": "rule-006",
		"category": "testing",
		"originalName": "it-effect-prop",
		"rule": "Never use hard-coded test data; use it.effect.prop with Schema",
		"example": "Multiple test inputs"
	},
	{
		"ruleId": "rule-007",
		"category": "testing",
		"originalName": "it-effect",
		"rule": "Never use Effect.runPromise in tests; use it.effect from @effect/vitest",
		"example": "Test with service dependencies"
	},
	{
		"ruleId": "rule-008",
		"category": "testing",
		"originalName": "it-live",
		"rule": "Never use it.effect when you need real time; use it.live",
		"example": "Testing with real clock/environment"
	},
	{
		"ruleId": "rule-009",
		"category": "testing",
		"originalName": "it-prop-schema",
		"rule": "Never use raw fc.integer/fc.string; use it.prop with Schema",
		"example": "Converting raw fast-check to Schema-based"
	},
	{
		"ruleId": "rule-010",
		"category": "testing",
		"originalName": "it-scoped",
		"rule": "Never manage resources manually in tests; use it.scoped",
		"example": "Testing with acquireRelease resources"
	},
	{
		"ruleId": "rule-011",
		"category": "testing",
		"originalName": "layer-effect-prop",
		"rule": "Never test with partial coverage; combine layer() with it.effect.prop",
		"example": "Full property-based integration test"
	},
	{
		"ruleId": "rule-012",
		"category": "testing",
		"originalName": "layer-test",
		"rule": "Never use live services in tests; use layer() from @effect/vitest",
		"example": "Testing with service dependencies"
	},
	{
		"ruleId": "rule-013",
		"category": "testing",
		"originalName": "property-based",
		"rule": "Never write manual property tests; use it.effect.prop",
		"example": "Property test with Effect"
	},
	{
		"ruleId": "rule-014",
		"category": "testing",
		"originalName": "schema-constraints",
		"rule": "Never use fast-check .filter(); use Schema constraints",
		"example": "Complex Schema constraints"
	},
	{
		"ruleId": "rule-015",
		"category": "testing",
		"originalName": "test-clock",
		"rule": "Never provide TestClock.layer manually; it.effect includes it automatically",
		"example": "Time-based testing"
	},
	{
		"ruleId": "rule-001",
		"category": "schema",
		"originalName": "branded-ids",
		"rule": "Never use raw primitives for IDs; use Schema.brand",
		"example": "Unbranded ID types"
	},
	{
		"ruleId": "rule-002",
		"category": "schema",
		"originalName": "no-plain-error",
		"rule": "Never extend plain Error class; use Schema.TaggedError",
		"example": "Domain error types"
	},
	{
		"ruleId": "rule-003",
		"category": "schema",
		"originalName": "parse-json",
		"rule": "Never use JSON.parse(); use Schema.parseJson()",
		"example": "Separate JSON.parse then validate (WRONG)"
	},
	{
		"ruleId": "rule-004",
		"category": "schema",
		"originalName": "schema-class-methods",
		"rule": "Never use Schema.Struct for entities with methods; use Schema.Class",
		"example": "Entity with computed properties"
	},
	{
		"ruleId": "rule-005",
		"category": "schema",
		"originalName": "schema-class",
		"rule": "Never use TypeScript type or interface for data structures; use Schema.Class or Schema.TaggedClass",
		"example": "Data structure definition"
	},
	{
		"ruleId": "rule-006",
		"category": "schema",
		"originalName": "schema-constructor",
		"rule": "Never construct object literals; use Schema class constructors",
		"example": "Creating data instances"
	},
	{
		"ruleId": "rule-007",
		"category": "schema",
		"originalName": "schema-filters",
		"rule": "Never use manual validation functions; use Schema filters",
		"example": "Validation constraints in schema"
	},
	{
		"ruleId": "rule-008",
		"category": "schema",
		"originalName": "schema-literal",
		"rule": "Never use TypeScript enum; use Schema.Literal",
		"example": "Converting TypeScript enums"
	},
	{
		"ruleId": "rule-009",
		"category": "schema",
		"originalName": "schema-tagged-error",
		"rule": "Never use Data.TaggedError; use Schema.TaggedError",
		"example": "Error type definition"
	},
	{
		"ruleId": "rule-010",
		"category": "schema",
		"originalName": "schema-transform",
		"rule": "Never use manual type conversions; use Schema.transform",
		"example": "Domain transformation (cents to dollars)"
	},
	{
		"ruleId": "rule-011",
		"category": "schema",
		"originalName": "schema-union",
		"rule": "Never use TypeScript union types; use Schema.Union of TaggedClass",
		"example": "Union type definition"
	},
	{
		"ruleId": "rule-012",
		"category": "schema",
		"originalName": "schema-unknown-legitimate",
		"rule": "Never use Schema.Any/Schema.Unknown unless genuinely unconstrained",
		"example": "Legitimate use of Schema.Unknown (exception cause)"
	},
	{
		"ruleId": "rule-013",
		"category": "schema",
		"originalName": "tagged-union-state",
		"rule": "Never use optional properties for state; use tagged unions",
		"example": "Order status with optional fields"
	},
	{
		"ruleId": "rule-001",
		"category": "code-style",
		"originalName": "dom-element",
		"rule": "Never use angle bracket casting (<Type>value); use Schema",
		"example": "Old-style type assertion"
	},
	{
		"ruleId": "rule-002",
		"category": "code-style",
		"originalName": "dynamic-data",
		"rule": "Never use 'as any'; fix the type or create a Schema",
		"example": "Working with dynamic data"
	},
	{
		"ruleId": "rule-003",
		"category": "code-style",
		"originalName": "dynamic-property-access",
		"rule": "Never use eslint-disable for any-type errors; use Schema",
		"example": "Dynamic property access"
	},
	{
		"ruleId": "rule-004",
		"category": "code-style",
		"originalName": "effect-fn-single-step",
		"rule": "Never use Effect.gen for simple single-step effects; use Effect.fn()",
		"example": "Single operation function"
	},
	{
		"ruleId": "rule-005",
		"category": "code-style",
		"originalName": "effect-fn-transformation",
		"rule": "Never write plain functions; use Effect.fn() or Effect.gen()",
		"example": "Simple data transformation"
	},
	{
		"ruleId": "rule-006",
		"category": "code-style",
		"originalName": "effect-gen-multi-step",
		"rule": "Use Effect.gen() for multi-step sequential operations",
		"example": "Multiple dependent operations"
	},
	{
		"ruleId": "rule-007",
		"category": "code-style",
		"originalName": "exhaustive-match",
		"rule": "Never use eslint-disable for exhaustive checks; use Match.exhaustive",
		"example": "Switch exhaustiveness"
	},
	{
		"ruleId": "rule-008",
		"category": "code-style",
		"originalName": "fat-arrow-syntax",
		"rule": "Never use the function keyword; use fat arrow syntax",
		"example": "Function declarations"
	},
	{
		"ruleId": "rule-009",
		"category": "code-style",
		"originalName": "fix-types",
		"rule": "Never suppress type errors with comments; fix the types",
		"example": "Type mismatch error"
	},
	{
		"ruleId": "rule-010",
		"category": "code-style",
		"originalName": "non-null-assertion",
		"rule": "Never use ! (non-null assertion); use Option or Effect",
		"example": "Asserting non-null value"
	},
	{
		"ruleId": "rule-011",
		"category": "code-style",
		"originalName": "ts-imports",
		"rule": "Never import from \".js\" files; always import from \".ts\" files directly",
		"example": "Module imports"
	},
	{
		"ruleId": "rule-012",
		"category": "code-style",
		"originalName": "unknown-conversion",
		"rule": "Never use 'as unknown as T'; define a Schema instead",
		"example": "Converting between types"
	},
	{
		"ruleId": "rule-013",
		"category": "code-style",
		"originalName": "unused-variable",
		"rule": "Never use eslint-disable comments; fix the underlying issue",
		"example": "Unused variable warning"
	},
	{
		"ruleId": "rule-014",
		"category": "code-style",
		"originalName": "validate-api-response",
		"rule": "Never use type casting (as); use Schema.decodeUnknown or type guards",
		"example": "Validating API response"
	},
	{
		"ruleId": "rule-001",
		"category": "errors",
		"originalName": "all-either-mode",
		"rule": "Never use fail-fast Promise.all; use Effect.all with mode: \"either\"",
		"example": "Get Either results for each operation"
	},
	{
		"ruleId": "rule-002",
		"category": "errors",
		"originalName": "catch-tag",
		"rule": "Never check error._tag manually; use Effect.catchTag",
		"example": "Recovering from specific errors"
	},
	{
		"ruleId": "rule-003",
		"category": "errors",
		"originalName": "catch-tags",
		"rule": "Never use switch on error._tag; use Effect.catchTags",
		"example": "Handling multiple error types"
	},
	{
		"ruleId": "rule-004",
		"category": "errors",
		"originalName": "conditional-fail",
		"rule": "Never use throw statements; use Effect.fail()",
		"example": "Conditional throw based on state"
	},
	{
		"ruleId": "rule-005",
		"category": "errors",
		"originalName": "effect-try-promise",
		"rule": "Never use try/catch with async; use Effect.tryPromise()",
		"example": "Wrapping async operation"
	},
	{
		"ruleId": "rule-006",
		"category": "errors",
		"originalName": "effect-try",
		"rule": "Never use try/catch blocks; use Effect.try()",
		"example": "Multiple try/catch blocks"
	},
	{
		"ruleId": "rule-007",
		"category": "errors",
		"originalName": "map-error",
		"rule": "Never rethrow transformed errors; use Effect.mapError",
		"example": "Transform low-level to domain errors"
	},
	{
		"ruleId": "rule-008",
		"category": "errors",
		"originalName": "or-else-fallback",
		"rule": "Never use catchAll for fallbacks; use Effect.orElse",
		"example": "Fallback to alternative"
	},
	{
		"ruleId": "rule-009",
		"category": "errors",
		"originalName": "retry-schedule",
		"rule": "Never use manual retry loops; use Effect.retry with Schedule",
		"example": "Retry only for specific errors"
	},
	{
		"ruleId": "rule-010",
		"category": "errors",
		"originalName": "sandbox-catch-tags",
		"rule": "Never use try/catch for Effect errors; use Effect.sandbox with catchTags",
		"example": "Handling defects and expected errors"
	},
	{
		"ruleId": "rule-011",
		"category": "errors",
		"originalName": "timeout-fail",
		"rule": "Never use setTimeout for timeouts; use Effect.timeout",
		"example": "Timeout with typed error"
	},
	{
		"ruleId": "rule-012",
		"category": "errors",
		"originalName": "typed-errors",
		"rule": "Never use untyped errors; use Schema.TaggedError",
		"example": "Multiple error types"
	},
	{
		"ruleId": "rule-001",
		"category": "native-apis",
		"originalName": "composing-two-functions",
		"rule": "Never nest two function calls; use Function.compose",
		"example": "Composing two functions"
	},
	{
		"ruleId": "rule-002",
		"category": "native-apis",
		"originalName": "conditional-transformation",
		"rule": "Never use (x) => x; use Function.identity",
		"example": "Conditional transformation"
	},
	{
		"ruleId": "rule-003",
		"category": "native-apis",
		"originalName": "converting-to-entries",
		"rule": "Never use Object.keys/values/entries; use Record module",
		"example": "Converting to entries"
	},
	{
		"ruleId": "rule-004",
		"category": "native-apis",
		"originalName": "data-transformation-pipeline",
		"rule": "Never use native method chaining; use pipe with Effect's Array module",
		"example": "Data transformation pipeline"
	},
	{
		"ruleId": "rule-005",
		"category": "native-apis",
		"originalName": "filter-and-transform-single-pass",
		"rule": "Never chain filter then map; use Array.filterMap in one pass",
		"example": "Filter and transform in single pass"
	},
	{
		"ruleId": "rule-006",
		"category": "native-apis",
		"originalName": "finding-with-default",
		"rule": "Never use array.find(); use Array.findFirst (returns Option)",
		"example": "Finding with default"
	},
	{
		"ruleId": "rule-007",
		"category": "native-apis",
		"originalName": "function-constant-value",
		"rule": "Never use () => value; use Function.constant",
		"example": "Function that always returns same value"
	},
	{
		"ruleId": "rule-008",
		"category": "native-apis",
		"originalName": "grouping-items-by-key",
		"rule": "Never manually group with loops; use Array.groupBy",
		"example": "Grouping items by key"
	},
	{
		"ruleId": "rule-009",
		"category": "native-apis",
		"originalName": "head-and-tail-access",
		"rule": "Never use array[index]; use Array.get or Array.head/last (returns Option)",
		"example": "Head and tail access"
	},
	{
		"ruleId": "rule-010",
		"category": "native-apis",
		"originalName": "omitting-fields",
		"rule": "Never use destructuring to omit fields; use Struct.omit",
		"example": "Omitting fields"
	},
	{
		"ruleId": "rule-011",
		"category": "native-apis",
		"originalName": "removing-duplicates",
		"rule": "Never use [...new Set()]; use Array.dedupe",
		"example": "Removing duplicates"
	},
	{
		"ruleId": "rule-012",
		"category": "native-apis",
		"originalName": "reusable-pipeline",
		"rule": "Never use nested function calls; use flow for composing pipelines",
		"example": "Building reusable transformation pipeline"
	},
	{
		"ruleId": "rule-013",
		"category": "native-apis",
		"originalName": "safe-property-access",
		"rule": "Never use record[key]; use Record.get (returns Option)",
		"example": "Safe property access"
	},
	{
		"ruleId": "rule-014",
		"category": "native-apis",
		"originalName": "struct-predicate",
		"rule": "Never use manual &&/|| for predicates; use Predicate.and/or/not",
		"example": "Struct predicate"
	},
	{
		"ruleId": "rule-015",
		"category": "native-apis",
		"originalName": "tuple-transformation",
		"rule": "Never use tuple[0]/tuple[1]; use Tuple.getFirst/getSecond",
		"example": "Tuple transformation"
	},
	{
		"ruleId": "rule-001",
		"category": "discriminated-unions",
		"originalName": "match-tag-dispatch",
		"rule": "Never use if/else on ._tag; use Match.tag for discriminated unions",
		"example": "Simple event dispatch"
	},
	{
		"ruleId": "rule-002",
		"category": "discriminated-unions",
		"originalName": "partitioning-by-tag",
		"rule": "Never use ._tag in array predicates; use Schema.is(Variant)",
		"example": "Partitioning by _tag"
	},
	{
		"ruleId": "rule-003",
		"category": "discriminated-unions",
		"originalName": "runtime-validation",
		"rule": "Never cast unknown to check ._tag; use Schema.is() for validation",
		"example": "Runtime validation of unknown input"
	},
	{
		"ruleId": "rule-004",
		"category": "discriminated-unions",
		"originalName": "schema-is-vs-match-tag",
		"rule": "Never use Match.tag when you need class methods; use Schema.is()",
		"example": "Choosing between Schema.is() and Match.tag"
	},
	{
		"ruleId": "rule-005",
		"category": "discriminated-unions",
		"originalName": "schema-tagged-error",
		"rule": "Never use Data.TaggedError; use Schema.TaggedError for full compatibility",
		"example": "Error handling with Schema.TaggedError"
	},
	{
		"ruleId": "rule-006",
		"category": "discriminated-unions",
		"originalName": "switch-on-tag",
		"rule": "Never check ._tag directly; use Schema.is(Variant)",
		"example": "Switch on _tag property"
	},
	{
		"ruleId": "rule-007",
		"category": "discriminated-unions",
		"originalName": "use-union-directly",
		"rule": "Never extract types from ._tag; use the union type directly",
		"example": "Extracting _tag as a type"
	},
	{
		"ruleId": "rule-001",
		"category": "services",
		"originalName": "context-tag-api",
		"rule": "Never call external APIs directly; use a Context.Tag service",
		"example": "HTTP API call"
	},
	{
		"ruleId": "rule-002",
		"category": "services",
		"originalName": "context-tag-filesystem",
		"rule": "Never use direct file I/O; use a Context.Tag service",
		"example": "File system operations"
	},
	{
		"ruleId": "rule-003",
		"category": "services",
		"originalName": "context-tag-repository",
		"rule": "Never access database directly; use a Context.Tag repository",
		"example": "Database operations"
	},
	{
		"ruleId": "rule-004",
		"category": "services",
		"originalName": "layer-composition",
		"rule": "Never provide services ad-hoc; compose layers with Layer.mergeAll/provide",
		"example": "Building application layer stack"
	},
	{
		"ruleId": "rule-005",
		"category": "services",
		"originalName": "layer-effect",
		"rule": "Never create services inline; use Layer.effect or Layer.succeed",
		"example": "Service with dependencies"
	},
	{
		"ruleId": "rule-006",
		"category": "services",
		"originalName": "live-and-test-layers",
		"rule": "Never create a service without both *Live and *Test layers",
		"example": "Complete layer setup"
	},
	{
		"ruleId": "rule-007",
		"category": "services",
		"originalName": "stateful-test-layer",
		"rule": "Never use stateless test mocks; use Layer.effect with Ref for state",
		"example": "Repository test layer maintaining state"
	},
	{
		"ruleId": "rule-008",
		"category": "services",
		"originalName": "wrap-third-party-sdk",
		"rule": "Never call third-party SDKs directly; wrap in a Context.Tag service",
		"example": "Third-party SDK usage (Stripe, SendGrid, AWS, etc.)"
	}
]
