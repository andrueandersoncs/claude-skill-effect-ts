{
  "id": "services",
  "name": "Services & Layers",
  "description": "NEVER call external APIs, databases, or file systems directly. ALL effectful dependencies MUST be behind a Context.Tag service. Every service MUST have both a *Live and *Test layer implementation for full testability.",
  "rules": [
    {
      "rule": "Never call external APIs directly; use a Context.Tag service",
      "example": {
        "description": "HTTP API call",
        "bad": "const getUser = (id: string) =>\n  Effect.tryPromise(() =>\n    fetch(`https://api.example.com/users/${id}`).then((r) => r.json())\n  )\n\n// Used directly in business logic\nconst processUser = (id: string) =>\n  Effect.gen(function* () {\n    const user = yield* getUser(id) // Direct API call - untestable!\n    return processData(user)\n  })",
        "good": "const UserId = Schema.String.pipe(Schema.brand(\"UserId\"))\n\nclass ApiError extends Schema.TaggedError<ApiError>()(\"ApiError\", {\n  cause: Schema.Unknown,\n}) {}\n\nclass UserApi extends Context.Tag(\"UserApi\")<\n  UserApi,\n  {\n    readonly getUser: (id: typeof UserId.Type) => Effect.Effect<User, ApiError>\n    readonly updateUser: (user: User) => Effect.Effect<void, ApiError>\n  }\n>() {}\n\nconst processUser = (id: typeof UserId.Type) =>\n  Effect.gen(function* () {\n    const api = yield* UserApi\n    const user = yield* api.getUser(id)\n    return processData(user)\n  })\n\nconst UserApiLive = Layer.succeed(UserApi, {\n  getUser: (id) =>\n    Effect.gen(function* () {\n      const response = yield* Effect.tryPromise({\n        try: () => fetch(`https://api.example.com/users/${id}`).then((r) => r.json()),\n        catch: (e) => new ApiError({ cause: e })\n      })\n      return yield* Schema.decodeUnknown(User)(response)\n    }),\n  updateUser: (user) =>\n    Effect.tryPromise({\n      try: () => fetch(`https://api.example.com/users/${user.id}`, {\n        method: \"PUT\",\n        body: JSON.stringify(user)\n      }),\n      catch: (e) => new ApiError({ cause: e })\n    })\n})\n\nconst UserApiTest = Layer.effect(\n  UserApi,\n  Effect.sync(() => {\n    const UserArb = Arbitrary.make(User)(fc)\n    return {\n      getUser: (id) => Effect.succeed(\n        pipe(fc.sample(UserArb, 1), Array.head, Option.getOrThrow)\n      ),\n      updateUser: () => Effect.void\n    }\n  })\n)"
      }
    },
    {
      "rule": "Never access database directly; use a Context.Tag repository",
      "example": {
        "description": "Database operations",
        "bad": "import { db } from \"./database\"\n\nconst findUser = (id: string) =>\n  Effect.tryPromise(() => db.query(\"SELECT * FROM users WHERE id = ?\", [id]))\n\nconst saveUser = (user: User) =>\n  Effect.tryPromise(() => db.query(\"INSERT INTO users VALUES (?)\", [user]))",
        "good": "const UserId = Schema.String.pipe(Schema.brand(\"UserId\"))\nconst Email = Schema.String.pipe(Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/))\n\nclass UserNotFound extends Schema.TaggedError<UserNotFound>()(\"UserNotFound\", {\n  userId: UserId,\n}) {}\n\nclass DatabaseError extends Schema.TaggedError<DatabaseError>()(\"DatabaseError\", {\n  cause: Schema.Unknown,\n}) {}\n\nclass UserRepository extends Context.Tag(\"UserRepository\")<\n  UserRepository,\n  {\n    readonly findById: (id: typeof UserId.Type) => Effect.Effect<User, UserNotFound>\n    readonly findByEmail: (email: typeof Email.Type) => Effect.Effect<User, UserNotFound>\n    readonly save: (user: User) => Effect.Effect<void, DatabaseError>\n    readonly delete: (id: typeof UserId.Type) => Effect.Effect<void, DatabaseError>\n  }\n>() {}\n\nconst UserRepositoryLive = Layer.effect(\n  UserRepository,\n  Effect.gen(function* () {\n    const db = yield* Database\n    return {\n      findById: (id) =>\n        Effect.tryPromise({\n          try: () => db.query(\"SELECT * FROM users WHERE id = ?\", [id]),\n          catch: () => new UserNotFound({ userId: id })\n        }),\n      findByEmail: (email) =>\n        Effect.tryPromise({\n          try: () => db.query(\"SELECT * FROM users WHERE email = ?\", [email]),\n          catch: () => new UserNotFound({ userId: email as typeof UserId.Type })\n        }),\n      save: (user) =>\n        Effect.tryPromise({\n          try: () => db.query(\"INSERT INTO users VALUES (?)\", [user]),\n          catch: (e) => new DatabaseError({ cause: e })\n        }),\n      delete: (id) =>\n        Effect.tryPromise({\n          try: () => db.query(\"DELETE FROM users WHERE id = ?\", [id]),\n          catch: (e) => new DatabaseError({ cause: e })\n        })\n    }\n  })\n)\n\nconst UserRepositoryTest = Layer.effect(\n  UserRepository,\n  Effect.gen(function* () {\n    const store = yield* Ref.make(HashMap.empty<typeof UserId.Type, User>())\n    const UserArb = Arbitrary.make(User)(fc)\n\n    return {\n      findById: (id: typeof UserId.Type) =>\n        Effect.gen(function* () {\n          const users = yield* Ref.get(store)\n          return yield* pipe(\n            HashMap.get(users, id),\n            Option.match({\n              onNone: () => Effect.fail(new UserNotFound({ userId: id })),\n              onSome: Effect.succeed\n            })\n          )\n        }).pipe(Effect.flatten),\n      findByEmail: (email: typeof Email.Type) =>\n        Effect.gen(function* () {\n          const users = yield* Ref.get(store)\n          return yield* pipe(\n            HashMap.values(users),\n            Array.findFirst((u) => u.email === email),\n            Option.match({\n              onNone: () => Effect.fail(new UserNotFound({ userId: email as typeof UserId.Type })),\n              onSome: Effect.succeed\n            })\n          )\n        }).pipe(Effect.flatten),\n      save: (user: User) =>\n        Ref.update(store, HashMap.set(user.id, user)),\n      delete: (id: typeof UserId.Type) =>\n        Ref.update(store, HashMap.remove(id))\n    }\n  })\n)"
      }
    },
    {
      "rule": "Never use direct file I/O; use a Context.Tag service",
      "example": {
        "description": "File system operations",
        "bad": "import * as fs from \"fs/promises\"\n\nconst readConfig = () =>\n  Effect.tryPromise(() => fs.readFile(\"config.json\", \"utf-8\"))\n\nconst writeLog = (message: string) =>\n  Effect.tryPromise(() => fs.appendFile(\"app.log\", message))",
        "good": "import { Function } from \"effect\"\n\nclass FileError extends Schema.TaggedError<FileError>()(\"FileError\", {\n  path: Schema.String,\n  cause: Schema.Unknown,\n}) {}\n\nclass FileSystem extends Context.Tag(\"FileSystem\")<\n  FileSystem,\n  {\n    readonly readFile: (path: string) => Effect.Effect<string, FileError>\n    readonly writeFile: (path: string, content: string) => Effect.Effect<void, FileError>\n    readonly appendFile: (path: string, content: string) => Effect.Effect<void, FileError>\n    readonly exists: (path: string) => Effect.Effect<boolean>\n  }\n>() {}\n\nconst FileSystemLive = Layer.succeed(FileSystem, {\n  readFile: (path) =>\n    Effect.tryPromise({\n      try: () => fs.readFile(path, \"utf-8\"),\n      catch: (e) => new FileError({ path, cause: e })\n    }),\n  writeFile: (path, content) =>\n    Effect.tryPromise({\n      try: () => fs.writeFile(path, content),\n      catch: (e) => new FileError({ path, cause: e })\n    }),\n  appendFile: (path, content) =>\n    Effect.tryPromise({\n      try: () => fs.appendFile(path, content),\n      catch: (e) => new FileError({ path, cause: e })\n    }),\n  exists: (path) =>\n    Effect.tryPromise({\n      try: () => fs.access(path),\n      catch: Function.identity\n    }).pipe(\n      Effect.as(true),\n      Effect.orElse(Function.constant(Effect.succeed(false)))\n    )\n})\n\nconst FileSystemTest = Layer.effect(\n  FileSystem,\n  Effect.gen(function* () {\n    const store = yield* Ref.make(HashMap.empty<string, string>())\n\n    return {\n      readFile: (path: string) =>\n        Effect.gen(function* () {\n          const files = yield* Ref.get(store)\n          return yield* pipe(\n            HashMap.get(files, path),\n            Option.match({\n              onNone: () => Effect.fail(new FileError({ path, cause: \"Not found\" })),\n              onSome: Effect.succeed\n            })\n          )\n        }).pipe(Effect.flatten),\n      writeFile: (path: string, content: string) =>\n        Ref.update(store, HashMap.set(path, content)),\n      appendFile: (path: string, content: string) =>\n        Ref.update(store, (files) =>\n          pipe(\n            HashMap.get(files, path),\n            Option.getOrElse(Function.constant(\"\")),\n            (existing) => HashMap.set(files, path, existing + content)\n          )\n        ),\n      exists: (path: string) =>\n        Ref.get(store).pipe(Effect.map(HashMap.has(path)))\n    }\n  })\n)"
      }
    },
    {
      "rule": "Never create a service without both *Live and *Test layers",
      "example": {
        "description": "Complete layer setup",
        "bad": "// Only has live implementation\nconst EmailServiceLive = Layer.succeed(EmailService, {\n  send: (email) => sendRealEmail(email)\n})\n\n// Tests hit real email service!\nit.effect(\"should send welcome email\", () =>\n  Effect.gen(function* () {\n    yield* sendWelcomeEmail(user)\n  }).pipe(Effect.provide(EmailServiceLive))\n)",
        "good": "const EmailServiceLive = Layer.succeed(EmailService, {\n  send: (email) => sendRealEmail(email)\n})\n\nconst EmailServiceTest = Layer.effect(\n  EmailService,\n  Effect.gen(function* () {\n    const sentEmails = yield* Ref.make<Array<Email>>([])\n\n    return {\n      send: (email: Email) =>\n        Ref.update(sentEmails, Array.append(email)),\n      getSentEmails: () =>\n        Ref.get(sentEmails)\n    }\n  })\n)\n\nit.effect(\"should send welcome email\", () =>\n  Effect.gen(function* () {\n    yield* sendWelcomeEmail(user)\n    const service = yield* EmailService\n    const sentEmails = yield* service.getSentEmails()\n    expect(Array.length(sentEmails)).toBe(1)\n    const firstEmail = pipe(sentEmails, Array.head, Option.getOrThrow)\n    expect(firstEmail.to).toBe(user.email)\n    expect(firstEmail.subject).toContain(\"Welcome\")\n  }).pipe(Effect.provide(EmailServiceTest))\n)"
      }
    },
    {
      "rule": "Never create services inline; use Layer.effect or Layer.succeed",
      "example": {
        "description": "Service with dependencies",
        "bad": "// Creating service implementation inline\nconst program = Effect.gen(function* () {\n  const db = yield* Database\n  const cache = yield* Cache\n\n  // Business logic mixed with service creation\n  const user = yield* db.query(\"...\")\n  yield* cache.set(user.id, user)\n})",
        "good": "const UserServiceLive = Layer.effect(\n  UserService,\n  Effect.gen(function* () {\n    const db = yield* Database\n    const cache = yield* Cache\n\n    return {\n      getUser: (id: typeof UserId.Type) =>\n        Effect.gen(function* () {\n          const cached = yield* cache.get(id)\n          return yield* Option.match(cached, {\n            onSome: (user) => Effect.succeed(user),\n            onNone: () =>\n              Effect.gen(function* () {\n                const user = yield* db.query(\"SELECT * FROM users WHERE id = ?\", [id])\n                yield* cache.set(id, user)\n                return user\n              })\n          })\n        })\n    }\n  })\n)\n\nconst AppLive = UserServiceLive.pipe(\n  Layer.provide(Layer.mergeAll(DatabaseLive, CacheLive))\n)"
      }
    },
    {
      "rule": "Never call third-party SDKs directly; wrap in a Context.Tag service",
      "example": {
        "description": "Third-party SDK usage (Stripe, SendGrid, AWS, etc.)",
        "bad": "import Stripe from \"stripe\"\n\nconst stripe = new Stripe(process.env.STRIPE_KEY)\n\n// Direct SDK call in business logic - untestable!\nconst processPayment = (amount: number) =>\n  Effect.tryPromise(() =>\n    stripe.charges.create({ amount, currency: \"usd\" })\n  )",
        "good": "import Stripe from \"stripe\"\n\nconst ChargeId = Schema.String.pipe(Schema.brand(\"ChargeId\"))\n\nclass ChargeResult extends Schema.Class<ChargeResult>(\"ChargeResult\")({\n  id: ChargeId,\n  amount: Schema.Number,\n  currency: Schema.String,\n  status: Schema.Literal(\"succeeded\", \"pending\", \"failed\"),\n}) {}\n\nclass PaymentError extends Schema.TaggedError<PaymentError>()(\"PaymentError\", {\n  cause: Schema.Unknown,\n}) {}\n\nclass RefundError extends Schema.TaggedError<RefundError>()(\"RefundError\", {\n  cause: Schema.Unknown,\n}) {}\n\nclass PaymentGateway extends Context.Tag(\"PaymentGateway\")<\n  PaymentGateway,\n  {\n    readonly charge: (amount: number, currency: string) => Effect.Effect<ChargeResult, PaymentError>\n    readonly refund: (chargeId: typeof ChargeId.Type) => Effect.Effect<void, RefundError>\n  }\n>() {}\n\nconst PaymentGatewayLive = Layer.effect(\n  PaymentGateway,\n  Effect.gen(function* () {\n    const config = yield* Config.string(\"STRIPE_KEY\")\n    const stripe = new Stripe(config)\n\n    return {\n      charge: (amount, currency) =>\n        Effect.gen(function* () {\n          const response = yield* Effect.tryPromise({\n            try: () => stripe.charges.create({ amount, currency }),\n            catch: (e) => new PaymentError({ cause: e })\n          })\n          return yield* Schema.decodeUnknown(ChargeResult)(response)\n        }),\n      refund: (chargeId) =>\n        Effect.tryPromise({\n          try: () => stripe.refunds.create({ charge: chargeId }),\n          catch: (e) => new RefundError({ cause: e })\n        })\n    }\n  })\n)\n\nconst PaymentGatewayTest = Layer.effect(\n  PaymentGateway,\n  Effect.sync(() => {\n    const ChargeResultArb = Arbitrary.make(ChargeResult)(fc)\n    return {\n      charge: (amount, currency) => Effect.succeed(\n        pipe(fc.sample(ChargeResultArb, 1), Array.head, Option.getOrThrow)\n      ),\n      refund: () => Effect.void\n    }\n  })\n)\n\nconst processPayment = (amount: number) =>\n  Effect.gen(function* () {\n    const gateway = yield* PaymentGateway\n    return yield* gateway.charge(amount, \"usd\")\n  })"
      }
    },
    {
      "rule": "Never provide services ad-hoc; compose layers with Layer.mergeAll/provide",
      "example": {
        "description": "Building application layer stack",
        "bad": "// Providing services ad-hoc throughout codebase\nconst result = yield* myEffect.pipe(\n  Effect.provideService(Logger, loggerImpl),\n  Effect.provideService(UserRepo, userRepoImpl),\n  Effect.provideService(EmailService, emailImpl)\n)",
        "good": "// Compose layers bottom-up in a dedicated module\n\n// Infrastructure layer (no dependencies)\nconst InfraLive = Layer.mergeAll(\n  DatabaseLive,\n  HttpClientLive,\n  LoggerLive\n)\n\n// Repository layer (depends on Infrastructure)\nconst RepositoriesLive = Layer.mergeAll(\n  UserRepositoryLive,\n  OrderRepositoryLive\n).pipe(Layer.provide(InfraLive))\n\n// Service layer (depends on Repositories)\nconst ServicesLive = Layer.mergeAll(\n  UserServiceLive,\n  OrderServiceLive,\n  EmailServiceLive\n).pipe(Layer.provide(RepositoriesLive))\n\n// Application entry point\nexport const AppLive = ServicesLive\n\n// Usage at boundary\nEffect.runPromise(program.pipe(Effect.provide(AppLive)))"
      }
    },
    {
      "rule": "Never use stateless test mocks; use Layer.effect with Ref for state",
      "example": {
        "description": "Repository test layer maintaining state",
        "bad": "// Stateless mock - can't test save then find\nconst UserRepositoryTest = Layer.succeed(UserRepository, {\n  findById: (id) => Effect.succeed({ id, name: \"Fixed\" }),\n  save: () => Effect.void,\n})",
        "good": "const UserId = Schema.String.pipe(Schema.brand(\"UserId\"))\n\nclass UserNotFound extends Schema.TaggedError<UserNotFound>()(\"UserNotFound\", {\n  userId: UserId,\n}) {}\n\nconst UserRepositoryTest = Layer.effect(\n  UserRepository,\n  Effect.gen(function* () {\n    const store = yield* Ref.make(HashMap.empty<typeof UserId.Type, User>())\n\n    return {\n      findById: (id: typeof UserId.Type) =>\n        Effect.gen(function* () {\n          const users = yield* Ref.get(store)\n          return yield* pipe(\n            HashMap.get(users, id),\n            Option.match({\n              onNone: () => Effect.fail(new UserNotFound({ userId: id })),\n              onSome: Effect.succeed\n            })\n          )\n        }).pipe(Effect.flatten),\n\n      save: (user: User) =>\n        Ref.update(store, HashMap.set(user.id, user)),\n\n      delete: (id: typeof UserId.Type) =>\n        Ref.update(store, HashMap.remove(id))\n    }\n  })\n)"
      }
    }
  ]
}
