{
  "id": "conditionals",
  "name": "Conditional Statements",
  "description": "ZERO if/else, switch/case, or ternary operators are acceptable in Effect code. Use Match module with Schema-based predicates for all conditional logic.",
  "rules": [
    {
      "rule": "Never use if/else chains; define Schema types for each condition and use Match.when with Schema.is",
      "example": {
        "description": "Multi-condition object matching with Schema-defined predicates",
        "bad": "if (order.total > 1000 && order.isPremium) {\n  return 0.25\n} else if (order.total > 1000) {\n  return 0.15\n} else if (order.isPremium) {\n  return 0.10\n} else {\n  return 0\n}",
        "good": "import { Function, Match, Schema } from \"effect\"\n\nconst HighValue = Schema.Struct({\n  total: Schema.Number.pipe(Schema.greaterThan(1000)),\n  isPremium: Schema.Boolean\n})\n\nconst HighValuePremium = Schema.Struct({\n  total: Schema.Number.pipe(Schema.greaterThan(1000)),\n  isPremium: Schema.Literal(true)\n})\n\nconst Premium = Schema.Struct({\n  total: Schema.Number,\n  isPremium: Schema.Literal(true)\n})\n\nconst calculateDiscount = (order: Order) =>\n  Match.value(order).pipe(\n    Match.when(Schema.is(HighValuePremium), Function.constant(0.25)),\n    Match.when(Schema.is(HighValue), Function.constant(0.15)),\n    Match.when(Schema.is(Premium), Function.constant(0.10)),\n    Match.orElse(Function.constant(0))\n  )"
      }
    },
    {
      "rule": "Never use switch/case statements; use Match.type with Match.tag for discriminated unions",
      "example": {
        "description": "Discriminated union event handling",
        "bad": "switch (event.type) {\n  case \"UserCreated\":\n    return notifyAdmin(event.userId)\n  case \"UserDeleted\":\n    return cleanupData(event.userId)\n  case \"OrderPlaced\":\n    return processOrder(event.orderId)\n  default:\n    throw new Error(\"Unknown event\")\n}",
        "good": "import { Match } from \"effect\"\n\nconst handleEvent = Match.type<AppEvent>().pipe(\n  Match.tag(\"UserCreated\", (e) => notifyAdmin(e.userId)),\n  Match.tag(\"UserDeleted\", (e) => cleanupData(e.userId)),\n  Match.tag(\"OrderPlaced\", (e) => processOrder(e.orderId)),\n  Match.exhaustive\n)"
      }
    },
    {
      "rule": "Never use ternary operators; define Schema types for each range and use Match.when with Schema.is",
      "example": {
        "description": "Nested ternary replaced with Schema-defined score ranges",
        "bad": "const level = score > 90 ? \"expert\" : score > 70 ? \"intermediate\" : \"beginner\"",
        "good": "import { Function, Match, Schema } from \"effect\"\n\nconst ExpertScore = Schema.Number.pipe(Schema.greaterThan(90))\nconst IntermediateScore = Schema.Number.pipe(Schema.greaterThan(70))\n\nconst level = Match.value(score).pipe(\n  Match.when(Schema.is(ExpertScore), Function.constant(\"expert\")),\n  Match.when(Schema.is(IntermediateScore), Function.constant(\"intermediate\")),\n  Match.orElse(Function.constant(\"beginner\"))\n)"
      }
    },
    {
      "rule": "Never use null checks (if x != null); use Option.match",
      "example": {
        "description": "Effectful handling of nullable",
        "bad": "if (maybeUser != null) {\n  await sendEmail(maybeUser.email)\n} else {\n  console.log(\"No user to notify\")\n}",
        "good": "import { Effect, Option } from \"effect\"\n\nOption.match(maybeUser, {\n  onNone: () => Effect.log(\"No user to notify\"),\n  onSome: (user) => sendEmail(user.email)\n})"
      }
    },
    {
      "rule": "Never use result/error flag checks; use Either.match or Effect.match with Schema.TaggedClass",
      "example": {
        "description": "Effect success/failure handling with Schema-defined result types",
        "bad": "try {\n  const user = await Effect.runPromise(getUser(id))\n  return { status: \"success\", user }\n} catch (error) {\n  return { status: \"error\", message: error.message }\n}",
        "good": "import { Effect, Schema } from \"effect\"\n\nclass ErrorResult extends Schema.TaggedClass<ErrorResult>()(\"ErrorResult\", {\n  status: Schema.Literal(\"error\"),\n  message: Schema.String\n}) {}\n\nclass SuccessResult extends Schema.TaggedClass<SuccessResult>()(\"SuccessResult\", {\n  status: Schema.Literal(\"success\"),\n  user: User\n}) {}\n\nEffect.match(getUser(id), {\n  onFailure: (error) => new ErrorResult({ status: \"error\", message: error.message }),\n  onSuccess: (user) => new SuccessResult({ status: \"success\", user })\n})"
      }
    },
    {
      "rule": "Never use array empty checks; use Array.match",
      "example": {
        "description": "First element with fallback",
        "bad": "const first = items.length > 0 ? items[0] : defaultItem",
        "good": "import { Array, Function } from \"effect\"\n\nconst first = Array.match(items, {\n  onEmpty: Function.constant(defaultItem),\n  onNonEmpty: (arr) => Array.headNonEmpty(arr)\n})"
      }
    },
    {
      "rule": "Never use conditional variable reassignment; define Schema types and use Match.when with Schema.is",
      "example": {
        "description": "Multi-condition assignment with Schema-defined conditions",
        "bad": "let result = defaultValue\nif (condition1) {\n  result = value1\n} else if (condition2) {\n  result = value2\n}",
        "good": "import { Function, Match, Schema } from \"effect\"\n\nconst Condition1Active = Schema.Struct({\n  condition1: Schema.Literal(true),\n  condition2: Schema.Boolean\n})\n\nconst Condition2Active = Schema.Struct({\n  condition1: Schema.Literal(false),\n  condition2: Schema.Literal(true)\n})\n\nconst result = Match.value({ condition1, condition2 }).pipe(\n  Match.when(Schema.is(Condition1Active), Function.constant(value1)),\n  Match.when(Schema.is(Condition2Active), Function.constant(value2)),\n  Match.orElse(Function.constant(defaultValue))\n)"
      }
    },
    {
      "rule": "Never use negative conditions in if statements; define Schema types for each case and use Match.when with Schema.is",
      "example": {
        "description": "Numeric classification with Schema-defined ranges",
        "bad": "if (n > 0) {\n  return \"positive\"\n} else {\n  return \"not positive\"\n}",
        "good": "import { Function, Match, Schema } from \"effect\"\n\nconst Zero = Schema.Literal(0)\nconst Negative = Schema.Number.pipe(Schema.negative())\nconst Positive = Schema.Number.pipe(Schema.positive())\n\nconst classify = Match.type<number>().pipe(\n  Match.when(Schema.is(Zero), Function.constant(\"zero\")),\n  Match.when(Schema.is(Negative), Function.constant(\"negative\")),\n  Match.when(Schema.is(Positive), Function.constant(\"positive\")),\n  Match.exhaustive\n)"
      }
    },
    {
      "rule": "Never use multiple OR conditions (||); define a Schema union with Schema.Literal and use Match.when with Schema.is",
      "example": {
        "description": "Matching any of several values with Schema.Literal union",
        "bad": "if (day === \"Saturday\" || day === \"Sunday\") {\n  return true\n}\nreturn false",
        "good": "import { Function, Match, Schema } from \"effect\"\n\nconst Weekend = Schema.Literal(\"Saturday\", \"Sunday\")\n\nconst isWeekend = Match.type<string>().pipe(\n  Match.when(Schema.is(Weekend), Function.constant(true)),\n  Match.orElse(Function.constant(false))\n)"
      }
    },
    {
      "rule": "Never use combined AND conditions (&&); define a Schema.Struct capturing all conditions and use Match.when with Schema.is",
      "example": {
        "description": "Matching multiple conditions with Schema.Struct",
        "bad": "if (user.role === \"admin\" && user.verified) {\n  return true\n}\nreturn false",
        "good": "import { Function, Match, Schema } from \"effect\"\n\nconst VerifiedAdmin = Schema.Struct({\n  role: Schema.Literal(\"admin\"),\n  verified: Schema.Literal(true)\n})\n\nconst canDelete = Match.type<User>().pipe(\n  Match.when(Schema.is(VerifiedAdmin), Function.constant(true)),\n  Match.orElse(Function.constant(false))\n)"
      }
    }
  ]
}
