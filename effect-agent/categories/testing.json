{
  "id": "testing",
  "name": "Testing Violations",
  "description": "ALL Effect tests MUST use @effect/vitest. NEVER use Effect.runPromise in tests. NEVER hand-craft test data - use Arbitrary.make(Schema). Combine service test layers with property testing for 100% coverage.",
  "rules": [
    {
      "rule": "Never use Effect.runPromise in tests; use it.effect from @effect/vitest",
      "example": {
        "description": "Test with service dependencies",
        "bad": "it(\"should process order\", async () => {\n  const result = await Effect.runPromise(\n    processOrder(order).pipe(\n      Effect.provide(TestLayer)\n    )\n  )\n  expect(result.status).toBe(\"completed\")\n})",
        "good": "it.effect(\"should process order\", () =>\n  Effect.gen(function* () {\n    const result = yield* processOrder(order)\n    expect(result.status).toBe(\"completed\")\n  }).pipe(Effect.provide(TestLayer))\n)"
      }
    },
    {
      "rule": "Never import from vitest directly; use @effect/vitest",
      "example": {
        "description": "Test file imports",
        "bad": "import { describe, it, expect } from \"vitest\"\nimport { Effect } from \"effect\"\n\ndescribe(\"UserService\", () => {\n  it(\"should create user\", async () => {\n    const result = await Effect.runPromise(createUser(data))\n    expect(result).toBeDefined()\n  })\n})",
        "good": "import { describe, it, expect } from \"@effect/vitest\"\nimport { Effect } from \"effect\"\n\ndescribe(\"UserService\", () => {\n  it.effect(\"should create user\", () =>\n    Effect.gen(function* () {\n      const result = yield* createUser(data)\n      expect(result).toBeDefined()\n    })\n  )\n})"
      }
    },
    {
      "rule": "Never use hard-coded test data; use it.effect.prop with Schema",
      "example": {
        "description": "Multiple test inputs",
        "bad": "const testOrders = [\n  { id: \"order-1\", total: 100, items: [\"a\", \"b\"] },\n  { id: \"order-2\", total: 200, items: [\"c\"] },\n  { id: \"order-3\", total: 50, items: [] },\n]\n\ntestOrders.forEach((order) => {\n  it(`should process order ${order.id}`, async () => {\n    const result = await processOrder(order)\n    expect(result).toBeDefined()\n  })\n})",
        "good": "// it.effect.prop generates test data from Schema and runs Effect tests\nit.effect.prop(\n  \"should process all valid orders\",\n  { order: Order },  // Schema as arbitrary source\n  ({ order }) =>\n    Effect.gen(function* () {\n      const result = yield* processOrder(order)\n      expect(result).toBeDefined()\n    })\n)"
      }
    },
    {
      "rule": "Never use fast-check .filter(); use Schema constraints",
      "example": {
        "description": "Complex Schema constraints",
        "bad": "const validUser = fc.record({\n  id: fc.string(),\n  name: fc.string(),\n  age: fc.integer(),\n  email: fc.string(),\n}).filter((u) =>\n  u.name.length > 0 &&\n  u.age >= 18 &&\n  u.email.includes(\"@\")\n)",
        "good": "const UserId = Schema.String.pipe(Schema.minLength(1), Schema.brand(\"UserId\"))\nconst Email = Schema.String.pipe(Schema.pattern(/^[^@]+@[^@]+\\.[^@]+$/))\nconst Age = Schema.Number.pipe(Schema.int(), Schema.greaterThanOrEqualTo(18))\n\nclass User extends Schema.Class<User>(\"User\")({\n  id: UserId,\n  name: Schema.NonEmptyString,\n  age: Age,\n  email: Email,\n}) {}\n\nconst UserArbitrary = Arbitrary.make(User)"
      }
    },
    {
      "rule": "Never write manual property tests; use it.effect.prop",
      "example": {
        "description": "Property test with Effect",
        "bad": "it(\"should process orders correctly\", async () => {\n  const orders = generateTestOrders(100)\n\n  for (const order of orders) {\n    const result = await Effect.runPromise(processOrder(order))\n    expect(result.status).toBe(\"completed\")\n  }\n})",
        "good": "// it.effect.prop handles property-based testing with Effect\nit.effect.prop(\n  \"should process any valid order\",\n  { order: Order },  // Schema used as arbitrary\n  ({ order }) =>\n    Effect.gen(function* () {\n      const result = yield* processOrder(order)\n      expect(result.status).toBe(\"completed\")\n    })\n)"
      }
    },
    {
      "rule": "Never use raw fc.integer/fc.string; use it.prop with Schema",
      "example": {
        "description": "Converting raw fast-check to Schema-based",
        "bad": "import * as fc from \"fast-check\"\n\nit(\"should be commutative\", () => {\n  fc.assert(\n    fc.property(fc.integer(), fc.integer(), (a, b) => {\n      expect(a + b).toBe(b + a)\n    })\n  )\n})",
        "good": "import { it, expect } from \"@effect/vitest\"\nimport { Schema } from \"effect\"\n\n// it.prop accepts Schema types directly as arbitraries\nit.prop(\n  \"should be commutative\",\n  { a: Schema.Int, b: Schema.Int },\n  ({ a, b }) => {\n    expect(a + b).toBe(b + a)\n  }\n)"
      }
    },
    {
      "rule": "Never use live services in tests; use layer() from @effect/vitest",
      "example": {
        "description": "Testing with service dependencies",
        "bad": "// Tests hit real database!\nit.effect(\"should get user\", () =>\n  Effect.gen(function* () {\n    const repo = yield* UserRepository\n    const user = yield* repo.findById(\"123\")\n    expect(user).toBeDefined()\n  }).pipe(Effect.provide(UserRepositoryLive))\n)",
        "good": "import { it, expect, layer } from \"@effect/vitest\"\n\n// Test layer with in-memory store\nconst UserRepositoryTest = Layer.effect(\n  UserRepository,\n  Effect.gen(function* () {\n    const store = yield* Ref.make<Map<string, User>>(new Map())\n    return {\n      findById: (id) => Effect.gen(function* () {\n        const users = yield* Ref.get(store)\n        return yield* pipe(\n          Option.fromNullable(users.get(id)),\n          Option.match({\n            onNone: () => Effect.fail(new UserNotFound({ userId: id })),\n            onSome: Effect.succeed\n          }),\n          Effect.flatten\n        )\n      }),\n      save: (user) => Ref.update(store, (m) => new Map(m).set(user.id, user))\n    }\n  })\n)\n\n// layer() shares the test layer and wraps tests in describe block\nlayer(UserRepositoryTest)(\"UserService\", (it) => {\n  it.effect.prop(\n    \"should save and find any user\",\n    { user: User },\n    ({ user }) =>\n      Effect.gen(function* () {\n        const repo = yield* UserRepository\n        yield* repo.save(user)\n        const found = yield* repo.findById(user.id)\n        expect(found).toEqual(user)\n      })\n  )\n})"
      }
    },
    {
      "rule": "Never hard-code values in test layers; use Arbitrary-generated values",
      "example": {
        "description": "Test layer with hard-coded responses",
        "bad": "const UserApiTest = Layer.succeed(UserApi, {\n  // Hard-coded response - same value every test run\n  getUser: (id) => Effect.succeed({\n    id: \"test-123\",\n    name: \"Test User\",\n    email: \"test@test.com\"\n  }),\n  // Not implemented - this code path won't be tested\n  updateUser: () => Effect.fail(new Error(\"Not implemented\"))\n})",
        "good": "const UserApiTest = Layer.effect(\n  UserApi,\n  Effect.sync(() => {\n    const UserArb = Arbitrary.make(User)(fc)\n    return {\n      getUser: (id) => Effect.succeed(\n        pipe(\n          fc.sample(UserArb, 1),\n          Array.head,\n          Option.getOrThrow\n        )\n      ),\n      updateUser: (user) => Effect.void\n    }\n  })\n)"
      }
    },
    {
      "rule": "Never test with partial coverage; combine layer() with it.effect.prop",
      "example": {
        "description": "Full property-based integration test",
        "bad": "// Partial coverage: hard-coded data + real services\nit(\"should process order\", async () => {\n  const testOrder = { id: \"order-1\", total: 100, userId: \"user-1\" }\n  const result = await Effect.runPromise(\n    processOrder(testOrder).pipe(Effect.provide(RealServicesLayer))\n  )\n  expect(result.status).toBe(\"completed\")\n})",
        "good": "import { layer } from \"@effect/vitest\"\n\n// 100% coverage: test layers + generated data\nconst TestEnv = Layer.mergeAll(\n  UserApiTest,\n  OrderRepositoryTest,\n  PaymentGatewayTest\n)\n\nlayer(TestEnv)(\"Order Processing\", (it) => {\n  it.effect.prop(\n    \"should process any valid order\",\n    { order: Order },\n    ({ order }) =>\n      Effect.gen(function* () {\n        const result = yield* processOrder(order)\n        expect(result.status).toBe(\"completed\")\n      })\n  )\n})"
      }
    },
    {
      "rule": "Never provide TestClock.layer manually; it.effect includes it automatically",
      "example": {
        "description": "Time-based testing",
        "bad": "it(\"should timeout after delay\", async () => {\n  await Effect.runPromise(\n    Effect.gen(function* () {\n      const fiber = yield* Effect.fork(Effect.sleep(\"1 hour\"))\n      yield* TestClock.adjust(\"1 hour\")\n      yield* Fiber.join(fiber)\n    }).pipe(Effect.provide(TestClock.layer))\n  )\n})",
        "good": "// it.effect automatically provides TestClock\nit.effect(\"should timeout after delay\", () =>\n  Effect.gen(function* () {\n    const fiber = yield* Effect.fork(Effect.sleep(\"1 hour\"))\n    yield* TestClock.adjust(\"1 hour\")\n    yield* Fiber.join(fiber)\n  })\n)"
      }
    },
    {
      "rule": "Never skip addEqualityTesters(); call it for Effect type equality",
      "example": {
        "description": "Setup for Effect equality assertions",
        "bad": "// Effect types may not compare correctly in expect()\nimport { it, expect } from \"@effect/vitest\"\n\nit.effect(\"should match\", () =>\n  Effect.gen(function* () {\n    const result = yield* getOption()\n    expect(result).toEqual(Option.some(42))  // May fail incorrectly\n  })\n)",
        "good": "// In vitest.setup.ts or at top of test file\nimport { addEqualityTesters } from \"@effect/vitest\"\naddEqualityTesters()\n\n// Now Effect types compare correctly\nit.effect(\"should match\", () =>\n  Effect.gen(function* () {\n    const result = yield* getOption()\n    expect(result).toEqual(Option.some(42))  // Works correctly\n  })\n)"
      }
    },
    {
      "rule": "Never manage resources manually in tests; use it.scoped",
      "example": {
        "description": "Testing with acquireRelease resources",
        "bad": "it(\"should use database connection\", async () => {\n  const conn = await connect()\n  try {\n    const result = await conn.query(\"SELECT 1\")\n    expect(result).toBeDefined()\n  } finally {\n    await conn.close()  // Manual cleanup\n  }\n})",
        "good": "it.scoped(\"should use database connection\", () =>\n  Effect.gen(function* () {\n    const conn = yield* acquireDbConnection\n    const result = yield* conn.query(\"SELECT 1\")\n    expect(result).toBeDefined()\n  })\n)"
      }
    },
    {
      "rule": "Never use it.effect when you need real time; use it.live",
      "example": {
        "description": "Testing with real clock/environment",
        "bad": "it.effect(\"should measure real time\", () =>\n  Effect.gen(function* () {\n    const start = Date.now()\n    yield* Effect.sleep(\"10 millis\")  // Uses TestClock - no real delay!\n    const elapsed = Date.now() - start\n    expect(elapsed).toBeGreaterThanOrEqual(10)  // Fails!\n  })\n)",
        "good": "// it.live uses real clock, logger, etc.\nit.live(\"should measure real time\", () =>\n  Effect.gen(function* () {\n    const start = Date.now()\n    yield* Effect.sleep(\"10 millis\")  // Real 10ms delay\n    const elapsed = Date.now() - start\n    expect(elapsed).toBeGreaterThanOrEqual(10)  // Passes\n  })\n)"
      }
    },
    {
      "rule": "Never use try/catch for error assertions; use Effect.exit",
      "example": {
        "description": "Asserting on error type and data",
        "bad": "it(\"should fail with UserNotFound\", async () => {\n  try {\n    await Effect.runPromise(getUser(\"nonexistent\"))\n    fail(\"Expected error\")\n  } catch (e) {\n    expect(e._tag).toBe(\"UserNotFound\")\n  }\n})",
        "good": "it.effect(\"should fail with UserNotFound\", () =>\n  Effect.gen(function* () {\n    const exit = yield* Effect.exit(getUser(\"nonexistent\"))\n\n    expect(Exit.isFailure(exit)).toBe(true)\n\n    Exit.match(exit, {\n      onFailure: (cause) => {\n        const error = Option.getOrThrow(Cause.failureOption(cause))\n        expect(Schema.is(UserNotFound)(error)).toBe(true)\n        expect(error.userId).toBe(\"nonexistent\")\n      },\n      onSuccess: () => expect.fail(\"Expected failure\")\n    })\n  })\n)"
      }
    },
    {
      "rule": "Never stub methods as \"not implemented\"; use Arbitrary-generated responses",
      "example": {
        "description": "Anti-pattern: stubbing methods as not implemented",
        "bad": "const TestLayer = Layer.succeed(MyService, {\n  getUser: (id) => Effect.succeed({ id, name: \"Hardcoded\" }),\n  updateUser: () => Effect.fail(new Error(\"Not implemented\")),  // Won't test this path!\n  deleteUser: () => Effect.fail(new Error(\"Not implemented\")),\n})",
        "good": "// Generate valid responses so all code paths can be exercised\nconst TestLayer = Layer.effect(\n  MyService,\n  Effect.sync(() => {\n    const UserArb = Arbitrary.make(User)(fc)\n    return {\n      getUser: (id) => Effect.succeed(\n        pipe(fc.sample(UserArb, 1), Array.head, Option.getOrThrow)\n      ),\n      updateUser: (user) => Effect.void,\n      deleteUser: (id) => Effect.void,\n    }\n  })\n)"
      }
    }
  ]
}
