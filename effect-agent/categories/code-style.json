{
  "id": "code-style",
  "name": "Code Style & Hygiene",
  "description": "NEVER use type casting, ESLint disable comments, or plain functions. Use Schema for validation, Effect.fn()/Effect.gen() for functions, and fix lint errors at the source.",
  "rules": [
    {
      "rule": "Never use type casting (as); use Schema.decodeUnknown or type guards",
      "example": {
        "description": "Validating API response",
        "bad": "const fetchUser = async (id: string) => {\n  const response = await fetch(`/users/${id}`)\n  const data = await response.json()\n  return data as User  // Type casting - no runtime validation!\n}",
        "good": "class User extends Schema.Class<User>(\"User\")({\n  id: Schema.String,\n  name: Schema.String,\n  email: Schema.String,\n}) {}\n\nconst fetchUser = (id: string) =>\n  Effect.gen(function* () {\n    const response = yield* Effect.tryPromise({\n      try: () => fetch(`/users/${id}`).then((r) => r.json()),\n      catch: (e) => new FetchError({ cause: e })\n    })\n    return yield* Schema.decodeUnknown(User)(response)\n  })"
      }
    },
    {
      "rule": "Never use 'as unknown as T'; define a Schema instead",
      "example": {
        "description": "Converting between types",
        "bad": "const legacyData = getLegacyData()\nconst newFormat = legacyData as unknown as NewFormat",
        "good": "const NewFormat = Schema.Struct({\n  id: Schema.String,\n  value: Schema.Number,\n})\n\nconst convertLegacy = (legacyData: unknown) =>\n  Schema.decodeUnknown(NewFormat)(legacyData)"
      }
    },
    {
      "rule": "Never use 'as any'; fix the type or create a Schema",
      "example": {
        "description": "Working with dynamic data",
        "bad": "const processEvent = (event: unknown) => {\n  const typed = event as any\n  return typed.payload.data\n}",
        "good": "const Event = Schema.Struct({\n  payload: Schema.Struct({\n    data: Schema.Unknown\n  })\n})\n\nconst processEvent = (event: unknown) =>\n  Effect.gen(function* () {\n    const typed = yield* Schema.decodeUnknown(Event)(event)\n    return typed.payload.data\n  })"
      }
    },
    {
      "rule": "Never use angle bracket casting (<Type>value); use Schema",
      "example": {
        "description": "Old-style type assertion",
        "bad": "const element = <HTMLInputElement>document.getElementById(\"input\")",
        "good": "const getInput = (id: string) =>\n  Effect.gen(function* () {\n    const el = yield* Effect.sync(() => document.getElementById(id))\n    return yield* pipe(\n      Option.fromNullable(el),\n      Option.filter((e): e is HTMLInputElement => e instanceof HTMLInputElement),\n      Effect.fromOption,\n      Effect.mapError(() => new ElementNotFound({ id }))\n    )\n  })"
      }
    },
    {
      "rule": "Never write plain functions; use Effect.fn() or Effect.gen()",
      "example": {
        "description": "Simple data transformation",
        "bad": "const calculateTotal = (items: Item[]): number =>\n  items.reduce((sum, item) => sum + item.price * item.quantity, 0)",
        "good": "const calculateTotal = Effect.fn(\"calculateTotal\")(\n  (items: Array<Item>) =>\n    Effect.succeed(\n      Array.reduce(items, 0, (sum, item) => sum + item.price * item.quantity)\n    )\n)"
      }
    },
    {
      "rule": "Never use Effect.gen for simple single-step effects; use Effect.fn()",
      "example": {
        "description": "Single operation function",
        "bad": "const getConfig = (key: string) =>\n  Effect.gen(function* () {\n    return yield* Config.string(key)\n  })",
        "good": "const getConfig = Effect.fn(\"getConfig\")(\n  (key: string) => Config.string(key)\n)"
      }
    },
    {
      "rule": "Use Effect.gen() for multi-step sequential operations",
      "example": {
        "description": "Multiple dependent operations",
        "bad": "const processOrder = (orderId: string) =>\n  getOrder(orderId).pipe(\n    Effect.flatMap((order) =>\n      validateOrder(order).pipe(\n        Effect.flatMap((validated) =>\n          saveOrder(validated).pipe(\n            Effect.map((saved) => ({ order: saved, status: \"completed\" }))\n          )\n        )\n      )\n    )\n  )",
        "good": "const processOrder = (orderId: string) =>\n  Effect.gen(function* () {\n    const order = yield* getOrder(orderId)\n    const validated = yield* validateOrder(order)\n    const saved = yield* saveOrder(validated)\n    return { order: saved, status: \"completed\" }\n  })"
      }
    },
    {
      "rule": "Never use eslint-disable comments; fix the underlying issue",
      "example": {
        "description": "Unused variable warning",
        "bad": "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst _unusedValue = someFunction()",
        "good": "const result = someFunction()\nreturn processResult(result)"
      }
    },
    {
      "rule": "Never use eslint-disable for any-type errors; use Schema",
      "example": {
        "description": "Dynamic property access",
        "bad": "// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst getValue = (obj: any, key: string) => obj[key]",
        "good": "const getValue = <K extends string>(\n  obj: Record<K, unknown>,\n  key: K\n) =>\n  pipe(\n    Record.get(obj, key),\n    Option.getOrElse(() => undefined)\n  )"
      }
    },
    {
      "rule": "Never use eslint-disable for exhaustive checks; use Match.exhaustive",
      "example": {
        "description": "Switch exhaustiveness",
        "bad": "const handleStatus = (status: Status) => {\n  switch (status) {\n    case \"pending\": return \"Waiting\"\n    case \"active\": return \"Running\"\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    default: return \"Unknown\"\n  }\n}",
        "good": "const handleStatus = Match.type<Status>().pipe(\n  Match.when(\"pending\", () => \"Waiting\"),\n  Match.when(\"active\", () => \"Running\"),\n  Match.when(\"completed\", () => \"Done\"),\n  Match.exhaustive\n)"
      }
    },
    {
      "rule": "Never suppress type errors with comments; fix the types",
      "example": {
        "description": "Type mismatch error",
        "bad": "// @ts-ignore - TODO fix types later\nconst result = incompatibleFunction(data)\n\n// @ts-expect-error - library types are wrong\nconst value = thirdPartyLib.method()",
        "good": "const InputSchema = Schema.Struct({\n  data: Schema.String\n})\n\nconst result = Effect.gen(function* () {\n  const validated = yield* Schema.decodeUnknown(InputSchema)(data)\n  return yield* compatibleFunction(validated)\n})"
      }
    },
    {
      "rule": "Never use ! (non-null assertion); use Option or Effect",
      "example": {
        "description": "Asserting non-null value",
        "bad": "const user = users.find((u) => u.id === id)!\nconst name = user.name",
        "good": "const user = pipe(\n  Array.findFirst(users, (u) => u.id === id),\n  Option.match({\n    onNone: () => Effect.fail(new UserNotFound({ userId: id })),\n    onSome: Effect.succeed\n  })\n)"
      }
    }
  ]
}
